[
  {
    "name": "sp_uint64",
    "kind": "typedef",
    "raw-comment": "/**\n * @file   api.h    Public API for libspotify\n *\n * @note   All input strings are expected to be in UTF-8\n * @note   All output strings are in UTF-8.\n *\n * @note   All usernames are valid XMPP nodeprep identifiers:\n *         http://tools.ietf.org/html/rfc3920#appendix-A\n *         If you need to store user data, we strongly advise you\n *         to use the canonical form of the username.\n */",
    "type": {
      "kind": "named-type",
      "name": "__int64",
      "qualifiers": [
        "unsigned"
      ]
    }
  },
  {
    "name": "sp_uint64",
    "kind": "typedef",
    "raw-comment": null,
    "type": {
      "kind": "named-type",
      "name": "uint64_t",
      "qualifiers": []
    }
  },
  {
    "name": "bool",
    "kind": "typedef",
    "raw-comment": null,
    "type": {
      "kind": "named-type",
      "name": "char",
      "qualifiers": [
        "unsigned"
      ]
    }
  },
  {
    "name": "byte",
    "kind": "typedef",
    "raw-comment": null,
    "type": {
      "kind": "named-type",
      "name": "char",
      "qualifiers": [
        "unsigned"
      ]
    }
  },
  {
    "name": "sp_session",
    "kind": "typedef",
    "raw-comment": "///< Representation of a session\n",
    "type": {
      "kind": "struct",
      "tag": "sp_session",
      "fields": null,
      "qualifiers": []
    }
  },
  {
    "name": "sp_track",
    "kind": "typedef",
    "raw-comment": "///< A track handle\n",
    "type": {
      "kind": "struct",
      "tag": "sp_track",
      "fields": null,
      "qualifiers": []
    }
  },
  {
    "name": "sp_album",
    "kind": "typedef",
    "raw-comment": "///< An album handle\n",
    "type": {
      "kind": "struct",
      "tag": "sp_album",
      "fields": null,
      "qualifiers": []
    }
  },
  {
    "name": "sp_artist",
    "kind": "typedef",
    "raw-comment": "///< An artist handle\n",
    "type": {
      "kind": "struct",
      "tag": "sp_artist",
      "fields": null,
      "qualifiers": []
    }
  },
  {
    "name": "sp_artistbrowse",
    "kind": "typedef",
    "raw-comment": "///< A handle to an artist browse result\n",
    "type": {
      "kind": "struct",
      "tag": "sp_artistbrowse",
      "fields": null,
      "qualifiers": []
    }
  },
  {
    "name": "sp_albumbrowse",
    "kind": "typedef",
    "raw-comment": "///< A handle to an album browse result\n",
    "type": {
      "kind": "struct",
      "tag": "sp_albumbrowse",
      "fields": null,
      "qualifiers": []
    }
  },
  {
    "name": "sp_toplistbrowse",
    "kind": "typedef",
    "raw-comment": "///< A handle to a toplist browse result\n",
    "type": {
      "kind": "struct",
      "tag": "sp_toplistbrowse",
      "fields": null,
      "qualifiers": []
    }
  },
  {
    "name": "sp_search",
    "kind": "typedef",
    "raw-comment": "///< A handle to a search result\n",
    "type": {
      "kind": "struct",
      "tag": "sp_search",
      "fields": null,
      "qualifiers": []
    }
  },
  {
    "name": "sp_link",
    "kind": "typedef",
    "raw-comment": "///< A handle to the libspotify internal representation of a URI\n",
    "type": {
      "kind": "struct",
      "tag": "sp_link",
      "fields": null,
      "qualifiers": []
    }
  },
  {
    "name": "sp_image",
    "kind": "typedef",
    "raw-comment": "///< A handle to an image\n",
    "type": {
      "kind": "struct",
      "tag": "sp_image",
      "fields": null,
      "qualifiers": []
    }
  },
  {
    "name": "sp_user",
    "kind": "typedef",
    "raw-comment": "///< A handle to a user\n",
    "type": {
      "kind": "struct",
      "tag": "sp_user",
      "fields": null,
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist",
    "kind": "typedef",
    "raw-comment": "///< A playlist handle\n",
    "type": {
      "kind": "struct",
      "tag": "sp_playlist",
      "fields": null,
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlistcontainer",
    "kind": "typedef",
    "raw-comment": "///< A playlist container (playlist containing other playlists) handle\n",
    "type": {
      "kind": "struct",
      "tag": "sp_playlistcontainer",
      "fields": null,
      "qualifiers": []
    }
  },
  {
    "name": "sp_inbox",
    "kind": "typedef",
    "raw-comment": "///< Add to inbox request handle\n",
    "type": {
      "kind": "struct",
      "tag": "sp_inbox",
      "fields": null,
      "qualifiers": []
    }
  },
  {
    "name": "sp_error",
    "kind": "typedef",
    "raw-comment": "/**\n * Error codes returned by various functions\n */",
    "type": {
      "kind": "enum",
      "tag": "sp_error",
      "constants": [
        {
          "Name": "SP_ERROR_OK",
          "Value": 0,
          "RawComment": "///< No errors encountered\n"
        },
        {
          "Name": "SP_ERROR_BAD_API_VERSION",
          "Value": 1,
          "RawComment": "///< The library version targeted does not match the one you claim you support\n"
        },
        {
          "Name": "SP_ERROR_API_INITIALIZATION_FAILED",
          "Value": 2,
          "RawComment": "///< Initialization of library failed - are cache locations etc. valid?\n"
        },
        {
          "Name": "SP_ERROR_TRACK_NOT_PLAYABLE",
          "Value": 3,
          "RawComment": "///< The track specified for playing cannot be played\n"
        },
        {
          "Name": "SP_ERROR_BAD_APPLICATION_KEY",
          "Value": 5,
          "RawComment": "///< The application key is invalid\n"
        },
        {
          "Name": "SP_ERROR_BAD_USERNAME_OR_PASSWORD",
          "Value": 6,
          "RawComment": "///< Login failed because of bad username and/or password\n"
        },
        {
          "Name": "SP_ERROR_USER_BANNED",
          "Value": 7,
          "RawComment": "///< The specified username is banned\n"
        },
        {
          "Name": "SP_ERROR_UNABLE_TO_CONTACT_SERVER",
          "Value": 8,
          "RawComment": "///< Cannot connect to the Spotify backend system\n"
        },
        {
          "Name": "SP_ERROR_CLIENT_TOO_OLD",
          "Value": 9,
          "RawComment": "///< Client is too old, library will need to be updated\n"
        },
        {
          "Name": "SP_ERROR_OTHER_PERMANENT",
          "Value": 10,
          "RawComment": "///< Some other error occurred, and it is permanent (e.g. trying to relogin will not help)\n"
        },
        {
          "Name": "SP_ERROR_BAD_USER_AGENT",
          "Value": 11,
          "RawComment": "///< The user agent string is invalid or too long\n"
        },
        {
          "Name": "SP_ERROR_MISSING_CALLBACK",
          "Value": 12,
          "RawComment": "///< No valid callback registered to handle events\n"
        },
        {
          "Name": "SP_ERROR_INVALID_INDATA",
          "Value": 13,
          "RawComment": "///< Input data was either missing or invalid\n"
        },
        {
          "Name": "SP_ERROR_INDEX_OUT_OF_RANGE",
          "Value": 14,
          "RawComment": "///< Index out of range\n"
        },
        {
          "Name": "SP_ERROR_USER_NEEDS_PREMIUM",
          "Value": 15,
          "RawComment": "///< The specified user needs a premium account\n"
        },
        {
          "Name": "SP_ERROR_OTHER_TRANSIENT",
          "Value": 16,
          "RawComment": "///< A transient error occurred.\n"
        },
        {
          "Name": "SP_ERROR_IS_LOADING",
          "Value": 17,
          "RawComment": "///< The resource is currently loading\n"
        },
        {
          "Name": "SP_ERROR_NO_STREAM_AVAILABLE",
          "Value": 18,
          "RawComment": "///< Could not find any suitable stream to play\n"
        },
        {
          "Name": "SP_ERROR_PERMISSION_DENIED",
          "Value": 19,
          "RawComment": "///< Requested operation is not allowed\n"
        },
        {
          "Name": "SP_ERROR_INBOX_IS_FULL",
          "Value": 20,
          "RawComment": "///< Target inbox is full\n"
        },
        {
          "Name": "SP_ERROR_NO_CACHE",
          "Value": 21,
          "RawComment": "///< Cache is not enabled\n"
        },
        {
          "Name": "SP_ERROR_NO_SUCH_USER",
          "Value": 22,
          "RawComment": "///< Requested user does not exist\n"
        },
        {
          "Name": "SP_ERROR_NO_CREDENTIALS",
          "Value": 23,
          "RawComment": "///< No credentials are stored\n"
        },
        {
          "Name": "SP_ERROR_NETWORK_DISABLED",
          "Value": 24,
          "RawComment": "///< Network disabled\n"
        },
        {
          "Name": "SP_ERROR_INVALID_DEVICE_ID",
          "Value": 25,
          "RawComment": "///< Invalid device ID\n"
        },
        {
          "Name": "SP_ERROR_CANT_OPEN_TRACE_FILE",
          "Value": 26,
          "RawComment": "///< Unable to open trace file\n"
        },
        {
          "Name": "SP_ERROR_APPLICATION_BANNED",
          "Value": 27,
          "RawComment": "///< This application is no longer allowed to use the Spotify service\n"
        },
        {
          "Name": "SP_ERROR_OFFLINE_TOO_MANY_TRACKS",
          "Value": 31,
          "RawComment": "///< Reached the device limit for number of tracks to download\n"
        },
        {
          "Name": "SP_ERROR_OFFLINE_DISK_CACHE",
          "Value": 32,
          "RawComment": "///< Disk cache is full so no more tracks can be downloaded to offline mode\n"
        },
        {
          "Name": "SP_ERROR_OFFLINE_EXPIRED",
          "Value": 33,
          "RawComment": "///< Offline key has expired, the user needs to go online again\n"
        },
        {
          "Name": "SP_ERROR_OFFLINE_NOT_ALLOWED",
          "Value": 34,
          "RawComment": "///< This user is not allowed to use offline mode\n"
        },
        {
          "Name": "SP_ERROR_OFFLINE_LICENSE_LOST",
          "Value": 35,
          "RawComment": "///< The license for this device has been lost. Most likely because the user used offline on three other device\n"
        },
        {
          "Name": "SP_ERROR_OFFLINE_LICENSE_ERROR",
          "Value": 36,
          "RawComment": "///< The Spotify license server does not respond correctly\n"
        },
        {
          "Name": "SP_ERROR_LASTFM_AUTH_ERROR",
          "Value": 39,
          "RawComment": "///< A LastFM scrobble authentication error has occurred\n"
        },
        {
          "Name": "SP_ERROR_INVALID_ARGUMENT",
          "Value": 40,
          "RawComment": "///< An invalid argument was specified\n"
        },
        {
          "Name": "SP_ERROR_SYSTEM_FAILURE",
          "Value": 41,
          "RawComment": "///< An operating system error\n"
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_error_message",
    "kind": "instance",
    "raw-comment": "/**\n * Convert a numeric libspotify error code to a text string. The error message is in\n * English. This function is useful for logging purposes.\n *\n * @param[in]   error   The error code to lookup\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "error",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_error",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "char",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_connectionstate",
    "kind": "typedef",
    "raw-comment": "/**\n * Describes the current state of the connection\n */",
    "type": {
      "kind": "enum",
      "tag": "sp_connectionstate",
      "constants": [
        {
          "Name": "SP_CONNECTION_STATE_LOGGED_OUT",
          "Value": 0,
          "RawComment": "///< User not yet logged in\n"
        },
        {
          "Name": "SP_CONNECTION_STATE_LOGGED_IN",
          "Value": 1,
          "RawComment": "///< Logged in against a Spotify access point\n"
        },
        {
          "Name": "SP_CONNECTION_STATE_DISCONNECTED",
          "Value": 2,
          "RawComment": "///< Was logged in, but has now been disconnected\n"
        },
        {
          "Name": "SP_CONNECTION_STATE_UNDEFINED",
          "Value": 3,
          "RawComment": "///< The connection state is undefined\n"
        },
        {
          "Name": "SP_CONNECTION_STATE_OFFLINE",
          "Value": 4,
          "RawComment": "///< Logged in in offline mode\n"
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_sampletype",
    "kind": "typedef",
    "raw-comment": "/**\n * Sample type descriptor\n */",
    "type": {
      "kind": "enum",
      "tag": "sp_sampletype",
      "constants": [
        {
          "Name": "SP_SAMPLETYPE_INT16_NATIVE_ENDIAN",
          "Value": 0,
          "RawComment": "///< 16-bit signed integer samples\n"
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_audioformat",
    "kind": "typedef",
    "raw-comment": "/**\n * Audio format descriptor\n */",
    "type": {
      "kind": "struct",
      "tag": "sp_audioformat",
      "fields": [
        {
          "name": "sample_type",
          "kind": "instance",
          "raw-comment": "///< Sample type enum,\n",
          "type": {
            "kind": "named-type",
            "name": "sp_sampletype",
            "qualifiers": []
          }
        },
        {
          "name": "sample_rate",
          "kind": "instance",
          "raw-comment": "///< Audio sample rate, in samples per second.\n",
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "channels",
          "kind": "instance",
          "raw-comment": "///< Number of channels. Currently 1 or 2.\n",
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_bitrate",
    "kind": "typedef",
    "raw-comment": "/**\n * Bitrate definitions for music streaming\n */",
    "type": {
      "kind": "enum",
      "tag": "sp_bitrate",
      "constants": [
        {
          "Name": "SP_BITRATE_160k",
          "Value": 0,
          "RawComment": "///< Bitrate 160kbps\n"
        },
        {
          "Name": "SP_BITRATE_320k",
          "Value": 1,
          "RawComment": "///< Bitrate 320kbps\n"
        },
        {
          "Name": "SP_BITRATE_96k",
          "Value": 2,
          "RawComment": "///< Bitrate 96kbps\n"
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_type",
    "kind": "typedef",
    "raw-comment": "/**\n * Playlist types\n */",
    "type": {
      "kind": "enum",
      "tag": "sp_playlist_type",
      "constants": [
        {
          "Name": "SP_PLAYLIST_TYPE_PLAYLIST",
          "Value": 0,
          "RawComment": "///< A normal playlist.\n"
        },
        {
          "Name": "SP_PLAYLIST_TYPE_START_FOLDER",
          "Value": 1,
          "RawComment": "///< Marks a folder starting point,\n"
        },
        {
          "Name": "SP_PLAYLIST_TYPE_END_FOLDER",
          "Value": 2,
          "RawComment": "///< and ending point.\n"
        },
        {
          "Name": "SP_PLAYLIST_TYPE_PLACEHOLDER",
          "Value": 3,
          "RawComment": "///< Unknown entry.\n"
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_type",
    "kind": "typedef",
    "raw-comment": "/**\n * Search types\n */",
    "type": {
      "kind": "enum",
      "tag": "sp_search_type",
      "constants": [
        {
          "Name": "SP_SEARCH_STANDARD",
          "Value": 0,
          "RawComment": null
        },
        {
          "Name": "SP_SEARCH_SUGGEST",
          "Value": 1,
          "RawComment": null
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_offline_status",
    "kind": "typedef",
    "raw-comment": "/**\n * Playlist offline status\n */",
    "type": {
      "kind": "enum",
      "tag": "sp_playlist_offline_status",
      "constants": [
        {
          "Name": "SP_PLAYLIST_OFFLINE_STATUS_NO",
          "Value": 0,
          "RawComment": "///< Playlist is not offline enabled\n"
        },
        {
          "Name": "SP_PLAYLIST_OFFLINE_STATUS_YES",
          "Value": 1,
          "RawComment": "///< Playlist is synchronized to local storage\n"
        },
        {
          "Name": "SP_PLAYLIST_OFFLINE_STATUS_DOWNLOADING",
          "Value": 2,
          "RawComment": "///< This playlist is currently downloading. Only one playlist can be in this state any given time\n"
        },
        {
          "Name": "SP_PLAYLIST_OFFLINE_STATUS_WAITING",
          "Value": 3,
          "RawComment": "///< Playlist is queued for download\n"
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_availability",
    "kind": "typedef",
    "raw-comment": "/**\n * Track availability\n */",
    "type": {
      "kind": "enum",
      "tag": "sp_availability",
      "constants": [
        {
          "Name": "SP_TRACK_AVAILABILITY_UNAVAILABLE",
          "Value": 0,
          "RawComment": "///< Track is not available\n"
        },
        {
          "Name": "SP_TRACK_AVAILABILITY_AVAILABLE",
          "Value": 1,
          "RawComment": "///< Track is available and can be played\n"
        },
        {
          "Name": "SP_TRACK_AVAILABILITY_NOT_STREAMABLE",
          "Value": 2,
          "RawComment": "///< Track can not be streamed using this account\n"
        },
        {
          "Name": "SP_TRACK_AVAILABILITY_BANNED_BY_ARTIST",
          "Value": 3,
          "RawComment": "///< Track not available on artist's reqeust\n"
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_offline_status",
    "kind": "typedef",
    "raw-comment": "/**\n * Track offline status\n */",
    "type": {
      "kind": "enum",
      "tag": "sp_track_offline_status",
      "constants": [
        {
          "Name": "SP_TRACK_OFFLINE_NO",
          "Value": 0,
          "RawComment": "///< Not marked for offline\n"
        },
        {
          "Name": "SP_TRACK_OFFLINE_WAITING",
          "Value": 1,
          "RawComment": "///< Waiting for download\n"
        },
        {
          "Name": "SP_TRACK_OFFLINE_DOWNLOADING",
          "Value": 2,
          "RawComment": "///< Currently downloading\n"
        },
        {
          "Name": "SP_TRACK_OFFLINE_DONE",
          "Value": 3,
          "RawComment": "///< Downloaded OK and can be played\n"
        },
        {
          "Name": "SP_TRACK_OFFLINE_ERROR",
          "Value": 4,
          "RawComment": "///< Error during download\n"
        },
        {
          "Name": "SP_TRACK_OFFLINE_DONE_EXPIRED",
          "Value": 5,
          "RawComment": "///< Downloaded OK but not playable due to expiery\n"
        },
        {
          "Name": "SP_TRACK_OFFLINE_LIMIT_EXCEEDED",
          "Value": 6,
          "RawComment": "///< Waiting because device have reached max number of allowed tracks\n"
        },
        {
          "Name": "SP_TRACK_OFFLINE_DONE_RESYNC",
          "Value": 7,
          "RawComment": "///< Downloaded OK and available but scheduled for re-download\n"
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_image_size",
    "kind": "typedef",
    "raw-comment": "/**\n * Image size\n */",
    "type": {
      "kind": "enum",
      "tag": "sp_image_size",
      "constants": [
        {
          "Name": "SP_IMAGE_SIZE_NORMAL",
          "Value": 0,
          "RawComment": "///< Normal image size\n"
        },
        {
          "Name": "SP_IMAGE_SIZE_SMALL",
          "Value": 1,
          "RawComment": "///< Small image size\n"
        },
        {
          "Name": "SP_IMAGE_SIZE_LARGE",
          "Value": 2,
          "RawComment": "///< Large image size\n"
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_audio_buffer_stats",
    "kind": "typedef",
    "raw-comment": "/**\n * Buffer stats used by get_audio_buffer_stats callback\n */",
    "type": {
      "kind": "struct",
      "tag": "sp_audio_buffer_stats",
      "fields": [
        {
          "name": "samples",
          "kind": "instance",
          "raw-comment": "///< Samples in buffer\n",
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "stutter",
          "kind": "instance",
          "raw-comment": "///< Number of stutters (audio dropouts) since last query\n",
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_subscribers",
    "kind": "typedef",
    "raw-comment": "/**\n * List of subscribers returned by sp_playlist_subscribers()\n */",
    "type": {
      "kind": "struct",
      "tag": "sp_subscribers",
      "fields": [
        {
          "name": "count",
          "kind": "instance",
          "raw-comment": "///< Number of elements in 'subscribers'\n",
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": [
              "unsigned"
            ]
          }
        },
        {
          "name": "subscribers",
          "kind": "instance",
          "raw-comment": "///< Actual size is 'count'. Array of pointers to canonical usernames\n",
          "type": {
            "kind": "array",
            "dimension": 1,
            "of": {
              "kind": "pointer",
              "to": {
                "kind": "named-type",
                "name": "char",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_connection_type",
    "kind": "typedef",
    "raw-comment": "/**\n * Current connection type set using sp_session_set_connection_type()\n */",
    "type": {
      "kind": "enum",
      "tag": "sp_connection_type",
      "constants": [
        {
          "Name": "SP_CONNECTION_TYPE_UNKNOWN",
          "Value": 0,
          "RawComment": "///< Connection type unknown (Default)\n"
        },
        {
          "Name": "SP_CONNECTION_TYPE_NONE",
          "Value": 1,
          "RawComment": "///< No connection\n"
        },
        {
          "Name": "SP_CONNECTION_TYPE_MOBILE",
          "Value": 2,
          "RawComment": "///< Mobile data (EDGE, 3G, etc)\n"
        },
        {
          "Name": "SP_CONNECTION_TYPE_MOBILE_ROAMING",
          "Value": 3,
          "RawComment": "///< Roamed mobile data (EDGE, 3G, etc)\n"
        },
        {
          "Name": "SP_CONNECTION_TYPE_WIFI",
          "Value": 4,
          "RawComment": "///< Wireless connection\n"
        },
        {
          "Name": "SP_CONNECTION_TYPE_WIRED",
          "Value": 5,
          "RawComment": "///< Ethernet cable, etc\n"
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_connection_rules",
    "kind": "typedef",
    "raw-comment": "/**\n * Connection rules, bitwise OR of flags\n *\n * The default is SP_CONNECTION_RULE_NETWORK | SP_CONNECTION_RULE_ALLOW_SYNC\n */",
    "type": {
      "kind": "enum",
      "tag": "sp_connection_rules",
      "constants": [
        {
          "Name": "SP_CONNECTION_RULE_NETWORK",
          "Value": 1,
          "RawComment": "///< Allow network traffic. When not set libspotify will force itself into offline mode\n"
        },
        {
          "Name": "SP_CONNECTION_RULE_NETWORK_IF_ROAMING",
          "Value": 2,
          "RawComment": "///< Allow network traffic even if roaming\n"
        },
        {
          "Name": "SP_CONNECTION_RULE_ALLOW_SYNC_OVER_MOBILE",
          "Value": 4,
          "RawComment": "///< Set to allow syncing of offline content over mobile connections\n"
        },
        {
          "Name": "SP_CONNECTION_RULE_ALLOW_SYNC_OVER_WIFI",
          "Value": 8,
          "RawComment": "///< Set to allow syncing of offline content over WiFi\n"
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_artistbrowse_type",
    "kind": "typedef",
    "raw-comment": "/**\n * Controls the type of data that will be included in artist browse queries\n */",
    "type": {
      "kind": "enum",
      "tag": "sp_artistbrowse_type",
      "constants": [
        {
          "Name": "SP_ARTISTBROWSE_FULL",
          "Value": 0,
          "RawComment": "/**< All information except tophit tracks\n                   This mode is deprecated and will removed in a future release */"
        },
        {
          "Name": "SP_ARTISTBROWSE_NO_TRACKS",
          "Value": 1,
          "RawComment": "/**< Only albums and data about them, no tracks.\n             In other words, sp_artistbrowse_num_tracks() will return 0\n              */"
        },
        {
          "Name": "SP_ARTISTBROWSE_NO_ALBUMS",
          "Value": 2,
          "RawComment": "/**< Only return data about the artist (artist name, similar artist\n             biography, etc\n             No tracks or album will be abailable.\n             sp_artistbrowse_num_tracks() and sp_artistbrowse_num_albums()\n             will both return 0\n              */"
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_social_provider",
    "kind": "typedef",
    "raw-comment": null,
    "type": {
      "kind": "enum",
      "tag": "sp_social_provider",
      "constants": [
        {
          "Name": "SP_SOCIAL_PROVIDER_SPOTIFY",
          "Value": 0,
          "RawComment": null
        },
        {
          "Name": "SP_SOCIAL_PROVIDER_FACEBOOK",
          "Value": 1,
          "RawComment": null
        },
        {
          "Name": "SP_SOCIAL_PROVIDER_LASTFM",
          "Value": 2,
          "RawComment": null
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_scrobbling_state",
    "kind": "typedef",
    "raw-comment": null,
    "type": {
      "kind": "enum",
      "tag": "sp_scrobbling_state",
      "constants": [
        {
          "Name": "SP_SCROBBLING_STATE_USE_GLOBAL_SETTING",
          "Value": 0,
          "RawComment": null
        },
        {
          "Name": "SP_SCROBBLING_STATE_LOCAL_ENABLED",
          "Value": 1,
          "RawComment": null
        },
        {
          "Name": "SP_SCROBBLING_STATE_LOCAL_DISABLED",
          "Value": 2,
          "RawComment": null
        },
        {
          "Name": "SP_SCROBBLING_STATE_GLOBAL_ENABLED",
          "Value": 3,
          "RawComment": null
        },
        {
          "Name": "SP_SCROBBLING_STATE_GLOBAL_DISABLED",
          "Value": 4,
          "RawComment": null
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_offline_sync_status",
    "kind": "typedef",
    "raw-comment": "/**\n * Offline sync status\n */",
    "type": {
      "kind": "struct",
      "tag": "sp_offline_sync_status",
      "fields": [
        {
          "name": "queued_tracks",
          "kind": "instance",
          "raw-comment": "/**\n   * Queued tracks/bytes is things left to sync in current sync\n   * operation\n   */",
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "queued_bytes",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_uint64",
            "qualifiers": []
          }
        },
        {
          "name": "done_tracks",
          "kind": "instance",
          "raw-comment": "/**\n   * Done tracks/bytes is things marked for sync that existed on\n   * device before current sync operation\n   */",
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "done_bytes",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_uint64",
            "qualifiers": []
          }
        },
        {
          "name": "copied_tracks",
          "kind": "instance",
          "raw-comment": "/**\n   * Copied tracks/bytes is things that has been copied in\n   * current sync operation\n   */",
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "copied_bytes",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_uint64",
            "qualifiers": []
          }
        },
        {
          "name": "willnotcopy_tracks",
          "kind": "instance",
          "raw-comment": "/**\n   * Tracks that are marked as synced but will not be copied\n   * (for various reasons)\n   */",
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "error_tracks",
          "kind": "instance",
          "raw-comment": "/**\n   * A track is counted as error when something goes wrong while\n   * syncing the track\n   */",
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "syncing",
          "kind": "instance",
          "raw-comment": "/**\n   * Set if sync operation is in progress\n   */",
          "type": {
            "kind": "named-type",
            "name": "bool",
            "qualifiers": []
          }
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_callbacks",
    "kind": "typedef",
    "raw-comment": "/**\n * Session callbacks\n *\n * Registered when you create a session.\n * If some callbacks should not be of interest, set them to NULL.\n */",
    "type": {
      "kind": "struct",
      "tag": "sp_session_callbacks",
      "fields": [
        {
          "name": "logged_in",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when login has been processed and was successful\n   *\n   * @param[in]  session    Session\n   * @param[in]  error      One of the following errors, from ::sp_error\n   *                        SP_ERROR_OK\n   *                        SP_ERROR_CLIENT_TOO_OLD\n   *                        SP_ERROR_UNABLE_TO_CONTACT_SERVER\n   *                        SP_ERROR_BAD_USERNAME_OR_PASSWORD\n   *                        SP_ERROR_USER_BANNED\n   *                        SP_ERROR_USER_NEEDS_PREMIUM\n   *                        SP_ERROR_OTHER_TRANSIENT\n   *                        SP_ERROR_OTHER_PERMANENT\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "error",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "sp_error",
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "logged_out",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when logout has been processed. Either called explicitly\n   * if you initialize a logout operation, or implicitly if there\n   * is a permanent connection error\n   *\n   * @param[in]  session    Session\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "metadata_updated",
          "kind": "instance",
          "raw-comment": "/**\n   * Called whenever metadata has been updated\n   *\n   * If you have metadata cached outside of libspotify, you should purge\n   * your caches and fetch new versions.\n   *\n   * @param[in]  session    Session\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "connection_error",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when there is a connection error, and the library has problems\n   * reconnecting to the Spotify service. Could be called multiple times (as\n   * long as the problem is present)\n   *\n   *\n   * @param[in]  session    Session\n   * @param[in]  error      One of the following errors, from ::sp_error\n   *                        SP_ERROR_OK\n   *                        SP_ERROR_CLIENT_TOO_OLD\n   *                        SP_ERROR_UNABLE_TO_CONTACT_SERVER\n   *                        SP_ERROR_BAD_USERNAME_OR_PASSWORD\n   *                        SP_ERROR_USER_BANNED\n   *                        SP_ERROR_USER_NEEDS_PREMIUM\n   *                        SP_ERROR_OTHER_TRANSIENT\n   *                        SP_ERROR_OTHER_PERMANENT\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "error",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "sp_error",
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "message_to_user",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when the access point wants to display a message to the user\n   *\n   * In the desktop client, these are shown in a blueish toolbar just below the\n   * search box.\n   *\n   * @param[in]  session    Session\n   * @param[in]  message    String in UTF-8 format.\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "message",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "char",
                      "qualifiers": [
                        "const"
                      ]
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "notify_main_thread",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when processing needs to take place on the main thread.\n   *\n   * You need to call sp_session_process_events() in the main thread to get\n   * libspotify to do more work. Failure to do so may cause request timeouts,\n   * or a lost connection.\n   *\n   * @param[in]  session    Session\n   *\n   * @note This function is called from an internal session thread - you need to have proper synchronization!\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "music_delivery",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when there is decompressed audio data available.\n   *\n   * @param[in]  session    Session\n   * @param[in]  format     Audio format descriptor sp_audioformat\n   * @param[in]  frames     Points to raw PCM data as described by \\p format\n   * @param[in]  num_frames Number of available samples in \\p frames.\n   *                        If this is 0, a discontinuity has occurred (such as after a seek). The application\n   *                        should flush its audio fifos, etc.\n   *\n   * @return                Number of frames consumed.\n   *                        This value can be used to rate limit the output from the library if your\n   *                        output buffers are saturated. The library will retry delivery in about 100ms.\n   *\n   * @note This function is called from an internal session thread - you need to have proper synchronization!\n   *\n   * @note This function must never block. If your output buffers are full you must return 0 to signal\n   *       that the library should retry delivery in a short while.\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "format",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_audioformat",
                      "qualifiers": [
                        "const"
                      ]
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "frames",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "void",
                      "qualifiers": [
                        "const"
                      ]
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "num_frames",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "int",
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "int",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "play_token_lost",
          "kind": "instance",
          "raw-comment": "/**\n   * Music has been paused because an account only allows music\n   * to be played from one location simultaneously.\n   *\n   * @note When this callback is invoked the application should\n   *       behave just as if the user pressed the pause\n   *       button. The application should also display a message\n   *       to the user indicating the playback has been paused\n   *       because another application is playing using the same\n   *       account.\n   *\n   * @note IT MUST NOT automatically resume playback but must\n   *       instead wait for the user to press play.\n   *\n   * @param[in]  session    Session\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "log_message",
          "kind": "instance",
          "raw-comment": "/**\n   * Logging callback.\n   *\n   * @param[in]  session    Session\n   * @param[in]  data       Log data\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "data",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "char",
                      "qualifiers": [
                        "const"
                      ]
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "end_of_track",
          "kind": "instance",
          "raw-comment": "/**\n   * End of track.\n   * Called when the currently played track has reached its end.\n   *\n   * @note This function is invoked from the main thread\n   *\n   * @param[in]  session    Session\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "streaming_error",
          "kind": "instance",
          "raw-comment": "/**\n   * Streaming error.\n   * Called when streaming cannot start or continue.\n   *\n   * @note This function is invoked from the main thread\n   *\n   * @param[in]  session    Session\n   * @param[in]  error      One of the following errors, from ::sp_error\n   *                        SP_ERROR_NO_STREAM_AVAILABLE\n   *                        SP_ERROR_OTHER_TRANSIENT\n   *                        SP_ERROR_OTHER_PERMANENT\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "error",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "sp_error",
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "userinfo_updated",
          "kind": "instance",
          "raw-comment": "/**\n   * Called after user info (anything related to sp_user objects) have been updated.\n   *\n   * @param[in]  session    Session\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "start_playback",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when audio playback should start\n   *\n   * @note For this to work correctly the application must also implement get_audio_buffer_stats()\n   *\n   * @note This function is called from an internal session thread - you need to have proper synchronization!\n   *\n   * @note This function must never block.\n   *\n   * @param[in]  session    Session\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "stop_playback",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when audio playback should stop\n   *\n   * @note For this to work correctly the application must also implement get_audio_buffer_stats()\n   *\n   * @note This function is called from an internal session thread - you need to have proper synchronization!\n   *\n   * @note This function must never block.\n   *\n   * @param[in]  session    Session\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "get_audio_buffer_stats",
          "kind": "instance",
          "raw-comment": "/**\n   * Called to query application about its audio buffer\n   *\n   * @note This function is called from an internal session thread - you need to have proper synchronization!\n   *\n   * @note This function must never block.\n   *\n   * @param[in]  session    Session\n   * @param[out] stats      Stats struct to be filled by application\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "stats",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_audio_buffer_stats",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "offline_status_updated",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when offline synchronization status is updated\n   *\n   * @param[in]  session    Session\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "offline_error",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when offline synchronization status is updated\n   *\n   * @param[in]  session    Session\n   * @param[in]  error      Offline error. Will be SP_ERROR_OK if the offline synchronization\n   *                        error state has cleared\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "error",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "sp_error",
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "credentials_blob_updated",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when storable credentials have been updated, usually called when\n   * we have connected to the AP.\n   *\n   * @param[in]  session    Session\n   * @param[in]  blob   Blob is a null-terminated string which contains\n   *        an encrypted token that can be stored safely on disk\n   *        instead of storing plaintext passwords.\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "blob",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "char",
                      "qualifiers": [
                        "const"
                      ]
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "connectionstate_updated",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when the connection state has updated - such as when logging in, going offline, etc.\n   *\n   * @param[in]  session    Session\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "scrobble_error",
          "kind": "instance",
          "raw-comment": "/**\n  * Called when there is a scrobble error event\n  *\n  * @param[in]  session    Session\n  * @param[in]  error      Scrobble error. Currently SP_ERROR_LASTFM_AUTH_ERROR.\n  */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "error",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "sp_error",
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "private_session_mode_changed",
          "kind": "instance",
          "raw-comment": "/**\n  * Called when there is a change in the private session mode\n  *\n  * @param[in]  session    Session\n  * @param[in]  isPrivate  True if in private session, false otherwhise\n  */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "session",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_session",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "is_private",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "bool",
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_config",
    "kind": "typedef",
    "raw-comment": "/**\n * Session config\n */",
    "type": {
      "kind": "struct",
      "tag": "sp_session_config",
      "fields": [
        {
          "name": "api_version",
          "kind": "instance",
          "raw-comment": "///< The version of the Spotify API your application is compiled with. Set to #SPOTIFY_API_VERSION\n",
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "cache_location",
          "kind": "instance",
          "raw-comment": "/**< The location where Spotify will write cache files.\n            *   This cache include tracks, cached browse results and coverarts.\n                                          *   Set to empty string (\"\") to disable cache\n            */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "settings_location",
          "kind": "instance",
          "raw-comment": "/**< The location where Spotify will write setting files and per-user\n            *   cache items. This includes playlists, track metadata, etc.\n            *   'settings_location' may be the same path as 'cache_location'.\n            *   'settings_location' folder will not be created (unlike 'cache_location'),\n            *   if you don't want to create the folder yourself, you can set 'settings_location' to 'cache_location'.\n            */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "application_key",
          "kind": "instance",
          "raw-comment": "///< Your application key\n",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "void",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "application_key_size",
          "kind": "instance",
          "raw-comment": "///< The size of the application key in bytes\n",
          "type": {
            "kind": "named-type",
            "name": "size_t",
            "qualifiers": []
          }
        },
        {
          "name": "user_agent",
          "kind": "instance",
          "raw-comment": "/**< \"User-Agent\" for your application - max 255 characters long\n                 The User-Agent should be a relevant, customer facing identification of your application\n                 */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "callbacks",
          "kind": "instance",
          "raw-comment": "///< Delivery callbacks for session events, or NULL if you are not interested in any callbacks (not recommended!)\n",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session_callbacks",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "userdata",
          "kind": "instance",
          "raw-comment": "///< User supplied data for your application\n",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "void",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "compress_playlists",
          "kind": "instance",
          "raw-comment": "/**\n   * Compress local copy of playlists, reduces disk space usage\n   */",
          "type": {
            "kind": "named-type",
            "name": "bool",
            "qualifiers": []
          }
        },
        {
          "name": "dont_save_metadata_for_playlists",
          "kind": "instance",
          "raw-comment": "/**\n   * Don't save metadata for local copies of playlists\n   * Reduces disk space usage at the expense of needing\n   * to request metadata from Spotify backend when loading list\n   */",
          "type": {
            "kind": "named-type",
            "name": "bool",
            "qualifiers": []
          }
        },
        {
          "name": "initially_unload_playlists",
          "kind": "instance",
          "raw-comment": "/**\n   * Avoid loading playlists into RAM on startup.\n   * See sp_playlist_is_in_ram() for more details.\n   */",
          "type": {
            "kind": "named-type",
            "name": "bool",
            "qualifiers": []
          }
        },
        {
          "name": "device_id",
          "kind": "instance",
          "raw-comment": "/**\n   * Device ID for offline synchronization and logging purposes. The Device Id must be unique to the particular device instance,\n   * i.e. no two units must supply the same Device ID. The Device ID must not change between sessions or power cycles.\n   * Good examples is the device's MAC address or unique serial number.\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "proxy",
          "kind": "instance",
          "raw-comment": "/**\n   * Url to the proxy server that should be used.\n   * The format is protocol://<host>:port (where protocal is http/https/socks4/socks5)\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "proxy_username",
          "kind": "instance",
          "raw-comment": "/**\n   * Username to authenticate with proxy server\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "proxy_password",
          "kind": "instance",
          "raw-comment": "/**\n   * Password to authenticate with proxy server\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "tracefile",
          "kind": "instance",
          "raw-comment": "/**\n   * Path to API trace file\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_create",
    "kind": "instance",
    "raw-comment": "/**\n * Initialize a session. The session returned will be initialized, but you will need\n * to log in before you can perform any other operation\n * Currently it is not supported to have multiple active sessions, and it's recommended to only call this once per process.\n *\n * Here is a snippet from \\c spshell.c:\n * @dontinclude spshell.c\n * @skip config.api_version\n * @until }\n *\n * @param[in]   config    The configuration to use for the session\n * @param[out]  sess      If successful, a new session - otherwise NULL\n *\n * @return                One of the following errors, from ::sp_error\n *                        SP_ERROR_OK\n *                        SP_ERROR_BAD_API_VERSION\n *                        SP_ERROR_BAD_USER_AGENT\n *                        SP_ERROR_BAD_APPLICATION_KEY\n *                        SP_ERROR_API_INITIALIZATION_FAILED\n *                        SP_ERROR_INVALID_DEVICE_ID\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "config",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session_config",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "sess",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "pointer",
              "to": {
                "kind": "named-type",
                "name": "sp_session",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_release",
    "kind": "instance",
    "raw-comment": "/**\n * Release the session. This will clean up all data and connections associated with the session\n *\n * @param[in]   sess      Session object returned from sp_session_create()\n * @return                One of the following errors, from ::sp_error\n *                        SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "sess",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_login",
    "kind": "instance",
    "raw-comment": "/**\n * Logs in the specified username/password combo. This initiates the login in the background.\n * A callback is called when login is complete\n *\n * An application MUST NEVER store the user's password in clear text.\n * If automatic relogin is required, use sp_session_relogin()\n *\n * Here is a snippet from \\c spshell.c:\n * @dontinclude spshell.c\n * @skip sp_session_login\n * @until }\n *\n * @param[in]   session             Your session object\n * @param[in]   username            The username to log in\n * @param[in]   password            The password for the specified username\n * @param[in]   remember_me         If set, the username / password will be remembered by libspotify\n * @param[in]   blob              If you have received a blob in the #credentials_blob_updated\n *                                  you can pas this here instead of password\n * @return                          One of the following errors, from ::sp_error\n *                                  SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "username",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "password",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "remember_me",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "bool",
            "qualifiers": []
          }
        },
        {
          "name": "blob",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_relogin",
    "kind": "instance",
    "raw-comment": "/**\n * Log in the remembered user if last user that logged in logged in with remember_me set.\n * If no credentials are stored, this will return SP_ERROR_NO_CREDENTIALS.\n *\n * @param[in]   session      Your session object\n *\n * @return                 One of the following errors, from ::sp_error\n *                         SP_ERROR_OK\n *                         SP_ERROR_NO_CREDENTIALS\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_remembered_user",
    "kind": "instance",
    "raw-comment": "/**\n * Get username of the user that will be logged in via sp_session_relogin()\n *\n * @param[in]   session      Your session object\n * @param[out]  buffer       The buffer to hold the username\n * @param[in]   buffer_size  The max size of the buffer that will hold the username.\n *                           The resulting string is guaranteed to always be null terminated if\n *                           buffer_size > 0\n *\n * @return                   The number of characters in the username.\n *                           If value is greater or equal than \\p buffer_size, output was truncated.\n *                           If returned value is -1 no credentials are stored in libspotify.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "buffer",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "buffer_size",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "size_t",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_user_name",
    "kind": "instance",
    "raw-comment": "/**\n * Get a pointer to a string representing the user's login username.\n *\n * @param[in]   session         Your session object\n *\n * @return                   A string representing the login username.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "char",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_forget_me",
    "kind": "instance",
    "raw-comment": "/**\n * Remove stored credentials in libspotify. If no credentials are currently stored, nothing will happen.\n *\n * @param[in]   session      Your session object\n * @return                   One of the following errors, from ::sp_error\n *                           SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_user",
    "kind": "instance",
    "raw-comment": "/**\n * Fetches the currently logged in user\n *\n * @param[in]   session    Your session object\n *\n * @return                 The logged in user (or NULL if not logged in)\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_user",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_logout",
    "kind": "instance",
    "raw-comment": "/**\n * Logs out the currently logged in user\n *\n * Always call this before terminating the application and libspotify is currently\n * logged in. Otherwise, the settings and cache may be lost.\n *\n * @param[in]   session    Your session object\n * @return                 One of the following errors, from ::sp_error\n *                         SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_flush_caches",
    "kind": "instance",
    "raw-comment": "/**\n * Flush the caches\n *\n * This will make libspotify write all data that is meant to be stored\n * on disk to the disk immediately. libspotify does this periodically\n * by itself and also on logout. So under normal conditions this\n * should never need to be used.\n *\n * @param[in]   session    Your session object\n * @return                 One of the following errors, from ::sp_error\n *                         SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_connectionstate",
    "kind": "instance",
    "raw-comment": "/**\n * The connection state of the specified session.\n *\n * @param[in]   session    Your session object\n *\n * @return                 The connection state - see the sp_connectionstate enum for possible values\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_connectionstate",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_userdata",
    "kind": "instance",
    "raw-comment": "/**\n * The userdata associated with the session\n *\n * @param[in]   session    Your session object\n *\n * @return                 The userdata that was passed in on session creation\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "void",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_set_cache_size",
    "kind": "instance",
    "raw-comment": "/**\n * Set maximum cache size.\n *\n * @param[in]   session    Your session object\n * @param[in]   size       Maximum cache size in megabytes.\n *                         Setting it to 0 (the default) will let libspotify automatically\n *                         resize the cache (10% of disk free space)\n * @return                 One of the following errors, from ::sp_error\n *                         SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "size",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "size_t",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_process_events",
    "kind": "instance",
    "raw-comment": "/**\n * Make the specified session process any pending events\n *\n * @param[in]   session         Your session object\n * @param[out]  next_timeout    Stores the time (in milliseconds) until you should call this function again\n * @return                      One of the following errors, from ::sp_error\n *                              SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "next_timeout",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "int",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_player_load",
    "kind": "instance",
    "raw-comment": "/**\n * Loads the specified track\n *\n * After successfully loading the track, you have the option of running\n * sp_session_player_play() directly, or using sp_session_player_seek() first.\n * When this call returns, the track will have been loaded, unless an error occurred.\n *\n * @param[in]   session    Your session object\n * @param[in]   track      The track to be loaded\n *\n * @return                 One of the following errors, from ::sp_error\n *                         SP_ERROR_OK\n *                         SP_ERROR_MISSING_CALLBACK\n *                         SP_ERROR_TRACK_NOT_PLAYABLE\n *\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_player_seek",
    "kind": "instance",
    "raw-comment": "/**\n * Seek to position in the currently loaded track\n *\n * @param[in]   session    Your session object\n * @param[in]   offset     Track position, in milliseconds.\n * @return                 One of the following errors, from ::sp_error\n *                         SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "offset",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_player_play",
    "kind": "instance",
    "raw-comment": "/**\n * Play or pause the currently loaded track\n *\n * @param[in]   session    Your session object\n * @param[in]   play       If set to true, playback will occur. If set to false, the playback will be paused.\n * @return                 One of the following errors, from ::sp_error\n *                         SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "play",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "bool",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_player_unload",
    "kind": "instance",
    "raw-comment": "/**\n * Stops the currently playing track\n *\n * This frees some resources held by libspotify to identify the currently\n * playing track.\n *\n * @param[in]   session    Your session object\n * @return                 One of the following errors, from ::sp_error\n *                         SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_player_prefetch",
    "kind": "instance",
    "raw-comment": "/**\n * Prefetch a track\n *\n * Instruct libspotify to start loading of a track into its cache.\n * This could be done by an application just before the current track ends.\n *\n * @param[in]   session    Your session object\n * @param[in]   track      The track to be prefetched\n *\n * @return                 One of the following errors, from ::sp_error\n *                         SP_ERROR_NO_CACHE\n *                         SP_ERROR_OK\n *\n * @note Prefetching is only possible if a cache is configured\n *\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_playlistcontainer",
    "kind": "instance",
    "raw-comment": "/**\n * Returns the playlist container for the currently logged in user.\n *\n * @param[in]   session    Your session object\n *\n * @return                 Playlist container object, NULL if not logged in\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_playlistcontainer",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_inbox_create",
    "kind": "instance",
    "raw-comment": "/**\n * Returns an inbox playlist for the currently logged in user\n *\n * @param[in]  session        Session object\n *\n * @return     A playlist or NULL if no user is logged in\n * @note You need to release the playlist when you are done with it.\n * @see sp_playlist_release()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_playlist",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_starred_create",
    "kind": "instance",
    "raw-comment": "/**\n * Returns the starred list for the current user\n *\n * @param[in]  session        Session object\n *\n * @return     A playlist or NULL if no user is logged in\n * @note You need to release the playlist when you are done with it.\n * @see sp_playlist_release()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_playlist",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_starred_for_user_create",
    "kind": "instance",
    "raw-comment": "/**\n * Returns the starred list for a user\n *\n * @param[in]  session        Session object\n * @param[in]  canonical_username       Canonical username\n *\n * @return     A playlist or NULL if no user is logged in\n * @note You need to release the playlist when you are done with it.\n * @see sp_playlist_release()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "canonical_username",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_playlist",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_publishedcontainer_for_user_create",
    "kind": "instance",
    "raw-comment": "/**\n * Return the published container for a given @a canonical_username,\n * or the currently logged in user if @a canonical_username is NULL.\n *\n * When done with the list you should call sp_playlistconatiner_release() to\n * decrese the reference you own by having created it.\n *\n * @param[in]   session    Your session object.\n * @param[in]   canonical_username   The canonical username, or NULL.\n *\n * @return Playlist container object, NULL if not logged in.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "canonical_username",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_playlistcontainer",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_preferred_bitrate",
    "kind": "instance",
    "raw-comment": "/**\n * Set preferred bitrate for music streaming\n *\n * @param[in]  session        Session object\n * @param[in]  bitrate        Preferred bitrate, see ::sp_bitrate for possible values\n * @return                    One of the following errors, from ::sp_error\n *                            SP_ERROR_OK\n *                            SP_ERROR_INVALID_ARGUMENT\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "bitrate",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_bitrate",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_preferred_offline_bitrate",
    "kind": "instance",
    "raw-comment": "/**\n * Set preferred bitrate for offline sync\n *\n * @param[in]  session        Session object\n * @param[in]  bitrate        Preferred bitrate, see ::sp_bitrate for possible values\n * @param[in]  allow_resync   Set to true if libspotify should resynchronize already synchronized tracks. Usually you should set this to false.\n * @return                   One of the following errors, from ::sp_error\n *                           SP_ERROR_OK\n *                           SP_ERROR_INVALID_ARGUMENT\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "bitrate",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_bitrate",
            "qualifiers": []
          }
        },
        {
          "name": "allow_resync",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "bool",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_get_volume_normalization",
    "kind": "instance",
    "raw-comment": "/**\n * Return status of volume normalization\n *\n * @param[in]  session        Session object\n *\n * @return true iff volume normalization is enabled\n *\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_set_volume_normalization",
    "kind": "instance",
    "raw-comment": "/**\n * Set volume normalization\n *\n * @param[in]  session        Session object\n * @param[in]  on             True iff volume normalization should be enabled\n * @return                    One of the following errors, from ::sp_error\n *                            SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "on",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "bool",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_set_private_session",
    "kind": "instance",
    "raw-comment": "/**\n * Set if private session is enabled. This disables sharing what the user is listening to\n * to services such as Spotify Social, Facebook and LastFM. The private session will\n * last for a time, and then libspotify will revert to the normal state. The private\n * session is prolonged by user activity.\n *\n * @param[in]  session         Session object\n * @param[in]  enabled         True iff private session should be enabled\n * @return                     One of the following errors, from ::sp_error\n *                             SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "enabled",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "bool",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_is_private_session",
    "kind": "instance",
    "raw-comment": "/**\n * Return True if private session is enabled\n *\n * @param[in]  session         Session object\n *\n * @return     True if private session is enabled\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_set_scrobbling",
    "kind": "instance",
    "raw-comment": "/**\n * Set if scrobbling is enabled. This api allows setting local overrides of the global scrobbling settings.\n * Changing the global settings are currently not supported.\n *\n * @param[in]  session         Session object\n * @param[in]  provider        The scrobbling provider referred to\n * @param[in]  state           The state to set the provider to\n *\n * @return     error code\n *\n * @see sp_social_provider\n * @see sp_scrobbling_state\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "provider",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_social_provider",
            "qualifiers": []
          }
        },
        {
          "name": "state",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_scrobbling_state",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_is_scrobbling",
    "kind": "instance",
    "raw-comment": "/**\n * Return the scrobbling state. This makes it possible to find out if scrobbling is locally overrided or\n * if the global setting is used.\n *\n * @param[in]  session         Session object\n * @param[in]  provider        The scrobbling provider referred to\n * @param[out] state           The output variable receiving the sp_scrobbling_state state\n *\n * @return     error code\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "provider",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_social_provider",
            "qualifiers": []
          }
        },
        {
          "name": "state",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_scrobbling_state",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_is_scrobbling_possible",
    "kind": "instance",
    "raw-comment": "/**\n * Return True if scrobbling settings should be shown to the user. Currently this setting is relevant\n * only to the facebook provider.\n * The returned value may be false if the user is not connected to facebook,\n * or if the user has opted out from facebook social graph.\n *\n * @param[in]  session         Session object\n * @param[in]  provider        The scrobbling provider referred to\n * @param[out] out             True iff scrobbling is possible\n *\n * @return     error code\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "provider",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_social_provider",
            "qualifiers": []
          }
        },
        {
          "name": "out",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "bool",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_set_social_credentials",
    "kind": "instance",
    "raw-comment": "/**\n * Set the user's credentials with a social provider.\n * Currently this is only relevant for LastFm\n * Call sp_session_set_scrobbling to force an authentication attempt\n * with the LastFm server. If authentication fails a scrobble_error callback will be\n * sent.\n *\n * @param[in]  session         Session object\n * @param[in]  provider        The scrobbling provider referred to\n * @param[in]  username        The user name\n * @param[in]  password        The password\n *\n * @return     error code\n\n * @see sp_session_set_scrobbling\n * @see sp_session_callbacks#scrobble_error\n * @return                     One of the following errors, from ::sp_error\n *                             SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "provider",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_social_provider",
            "qualifiers": []
          }
        },
        {
          "name": "username",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "password",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_set_connection_type",
    "kind": "instance",
    "raw-comment": "/**\n * Set to true if the connection is currently routed over a roamed connectivity\n *\n * @param[in]  session        Session object\n * @param[in]  type           Connection type\n *\n * @note       Used in conjunction with sp_session_set_connection_rules() to control\n *             how libspotify should behave in respect to network activity and offline\n *             synchronization.\n * @see        sp_connection_type\n * @return     One of the following errors, from ::sp_error\n *             SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "type",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_connection_type",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_set_connection_rules",
    "kind": "instance",
    "raw-comment": "/**\n * Set rules for how libspotify connects to Spotify servers and synchronizes offline content\n *\n * @param[in]  session        Session object\n * @param[in]  rules          Connection rules\n *\n * @note       Used in conjunction with sp_session_set_connection_type() to control\n *             how libspotify should behave in respect to network activity and offline\n *             synchronization.\n * @see        sp_connection_rules\n * @return     One of the following errors, from ::sp_error\n *             SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "rules",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_connection_rules",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_offline_tracks_to_sync",
    "kind": "instance",
    "raw-comment": "/**\n * Get total number of tracks that needs download before everything\n * from all playlists that is marked for offline is fully synchronized\n *\n * @param[in]  session        Session object\n *\n * @return Number of tracks\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_offline_num_playlists",
    "kind": "instance",
    "raw-comment": "/**\n * Return number of playlisys that is marked for offline synchronization\n *\n * @param[in]  session        Session object\n *\n * @return Number of playlists\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_offline_sync_get_status",
    "kind": "instance",
    "raw-comment": "/**\n * Return offline synchronization status. When the internal status is\n * updated the offline_status_updated() callback will be invoked.\n *\n * @param[in]  session        Session object\n * @param[out] status         Status object that will be filled with info\n *\n * @return false if no synching is in progress (in which case the contents\n *               of status is undefined)\n *\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "status",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_offline_sync_status",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_offline_time_left",
    "kind": "instance",
    "raw-comment": "/**\n * Return remaining time (in seconds) until the offline key store expires\n * and the user is required to relogin\n *\n * @param[in]  session        Session object\n * @return                    Seconds until expiration\n *\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_session_user_country",
    "kind": "instance",
    "raw-comment": "/**\n * Get currently logged in users country\n * updated the offline_status_updated() callback will be invoked.\n *\n * @param[in]  session        Session object\n *\n * @return  Country encoded in an integer 'SE' = 'S' << 8 | 'E'\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_linktype",
    "kind": "typedef",
    "raw-comment": "/**\n * Link types\n */",
    "type": {
      "kind": "enum",
      "tag": "",
      "constants": [
        {
          "Name": "SP_LINKTYPE_INVALID",
          "Value": 0,
          "RawComment": "///< Link type not valid - default until the library has parsed the link, or when parsing failed\n"
        },
        {
          "Name": "SP_LINKTYPE_TRACK",
          "Value": 1,
          "RawComment": "///< Link type is track\n"
        },
        {
          "Name": "SP_LINKTYPE_ALBUM",
          "Value": 2,
          "RawComment": "///< Link type is album\n"
        },
        {
          "Name": "SP_LINKTYPE_ARTIST",
          "Value": 3,
          "RawComment": "///< Link type is artist\n"
        },
        {
          "Name": "SP_LINKTYPE_SEARCH",
          "Value": 4,
          "RawComment": "///< Link type is search\n"
        },
        {
          "Name": "SP_LINKTYPE_PLAYLIST",
          "Value": 5,
          "RawComment": "///< Link type is playlist\n"
        },
        {
          "Name": "SP_LINKTYPE_PROFILE",
          "Value": 6,
          "RawComment": "///< Link type is profile\n"
        },
        {
          "Name": "SP_LINKTYPE_STARRED",
          "Value": 7,
          "RawComment": "///< Link type is starred\n"
        },
        {
          "Name": "SP_LINKTYPE_LOCALTRACK",
          "Value": 8,
          "RawComment": "///< Link type is a local file\n"
        },
        {
          "Name": "SP_LINKTYPE_IMAGE",
          "Value": 9,
          "RawComment": "///< Link type is an image\n"
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_link_create_from_string",
    "kind": "instance",
    "raw-comment": "/**\n * Create a Spotify link given a string\n *\n * @param[in]   link       A string representation of a Spotify link\n *\n * @return                 A link representation of the given string representation.\n *                         If the link could not be parsed, this function returns NULL.\n *\n * @note You need to release the link when you are done with it.\n * @see sp_link_type()\n * @see sp_link_release()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "link",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_link",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_link_create_from_track",
    "kind": "instance",
    "raw-comment": "/**\n * Generates a link object from a track\n *\n * @param[in]   track        A track object\n * @param[in]   offset       Offset in track in ms.\n *\n * @return                   A link representing the track\n *\n * @note You need to release the link when you are done with it.\n * @see sp_link_release()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "offset",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_link",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_link_create_from_album",
    "kind": "instance",
    "raw-comment": "/**\n * Create a link object from an album\n *\n * @param[in]   album      An album object\n *\n * @return                 A link representing the album\n *\n * @note You need to release the link when you are done with it.\n * @see sp_link_release()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "album",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_album",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_link",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_link_create_from_album_cover",
    "kind": "instance",
    "raw-comment": "/**\n * Create an image link object from an album\n *\n * @param[in]   album      An album object\n * @param[in]   size       The desired size of the image\n *\n * @return                 A link representing the album cover. Type is set to SP_LINKTYPE_IMAGE\n *\n * @note You need to release the link when you are done with it.\n * @see sp_link_release()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "album",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_album",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "size",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_image_size",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_link",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_link_create_from_artist",
    "kind": "instance",
    "raw-comment": "/**\n * Creates a link object from an artist\n *\n * @param[in]   artist     An artist object\n *\n * @return                 A link object representing the artist\n *\n * @note You need to release the link when you are done with it.\n * @see sp_link_release()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "artist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_link",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_link_create_from_artist_portrait",
    "kind": "instance",
    "raw-comment": "/**\n * Creates a link object pointing to an artist portrait\n *\n * @param[in]   artist     Artist browse object\n * @param[in]   size       The desired size of the image\n *\n * @return                 A link object representing an image\n *\n * @note You need to release the link when you are done with it.\n * @see sp_link_release()\n * @see sp_artistbrowse_num_portraits()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "artist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "size",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_image_size",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_link",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_link_create_from_artistbrowse_portrait",
    "kind": "instance",
    "raw-comment": "/**\n * Creates a link object from an artist portrait\n *\n * @param[in]   arb        Artist browse object\n * @param[in]   index      The index of the portrait. Should be in the interval [0, sp_artistbrowse_num_portraits() - 1]\n *\n * @return                 A link object representing an image\n *\n * @note You need to release the link when you are done with it.\n * @see sp_link_release()\n * @see sp_artistbrowse_num_portraits()\n *\n * @note The difference from sp_link_create_from_artist_portrait() is\n * that the artist browse object may contain multiple portraits.\n *\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "arb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_link",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_link_create_from_search",
    "kind": "instance",
    "raw-comment": "/**\n * Generate a link object representing the current search\n *\n * @param[in]  search       Search object\n *\n * @return                  A link representing the search\n *\n * @note You need to release the link when you are done with it.\n * @see sp_link_release()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_link",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_link_create_from_playlist",
    "kind": "instance",
    "raw-comment": "/**\n * Create a link object representing the given playlist\n *\n * @param[in]  playlist       Playlist object\n *\n * @return                    A link representing the playlist\n *\n * @note You need to release the link when you are done with it.\n * @see sp_link_release()\n *\n * @note Due to reasons in the playlist backend design and the Spotify URI\n * scheme you need to wait for the playlist to be loaded before you can\n * successfully construct an URI. If sp_link_create_from_playlist() returns\n * NULL, try again after teh playlist_state_changed callback has fired.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_link",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_link_create_from_user",
    "kind": "instance",
    "raw-comment": "/**\n * Create a link object representing the given playlist\n *\n * @param[in]  user       User object\n *\n * @return                    A link representing the profile.\n *\n * @note You need to release the link when you are done with it.\n * @see sp_link_release()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "user",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_user",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_link",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_link_create_from_image",
    "kind": "instance",
    "raw-comment": "/**\n * Create a link object representing the given image\n *\n * @param[in]  image          Image object\n *\n * @return                    A link representing the image.\n *\n * @note You need to release the link when you are done with it.\n * @see sp_link_release()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "image",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_image",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_link",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_link_as_string",
    "kind": "instance",
    "raw-comment": "/**\n * Create a string representation of the given Spotify link\n *\n * @param[in]   link         The Spotify link whose string representation you are interested in\n * @param[out]  buffer       The buffer to hold the string representation of link\n * @param[in]   buffer_size  The max size of the buffer that will hold the string representation\n *                           The resulting string is guaranteed to always be null terminated if\n *                           buffer_size > 0\n *\n * @return                   The number of characters in the string representation of the link. If this\n *                           value is greater or equal than \\p buffer_size, output was truncated.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "link",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_link",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "buffer",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "buffer_size",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_link_type",
    "kind": "instance",
    "raw-comment": "/**\n * The link type of the specified link\n *\n * @param[in]   link       The Spotify link whose type you are interested in\n *\n * @return                 The link type of the specified link - see the sp_linktype enum for possible values\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "link",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_link",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_linktype",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_link_as_track",
    "kind": "instance",
    "raw-comment": "/**\n * The track representation for the given link\n *\n * @param[in]   link       The Spotify link whose track you are interested in\n *\n * @return                 The track representation of the given track link\n *                         If the link is not of track type then NULL is returned.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "link",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_link",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_track",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_link_as_track_and_offset",
    "kind": "instance",
    "raw-comment": "/**\n * The track and offset into track representation for the given link\n *\n * @param[in]   link       The Spotify link whose track you are interested in\n * @param[out]  offset     Pointer to offset into track (in milliseconds). If the link\n *                         does not contain an offset this will be set to 0.\n *\n * @return                 The track representation of the given track link\n *                         If the link is not of track type then NULL is returned.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "link",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_link",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "offset",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "int",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_track",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_link_as_album",
    "kind": "instance",
    "raw-comment": "/**\n * The album representation for the given link\n *\n * @param[in]   link       The Spotify link whose album you are interested in\n *\n * @return                 The album representation of the given album link\n *                         If the link is not of album type then NULL is returned\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "link",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_link",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_album",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_link_as_artist",
    "kind": "instance",
    "raw-comment": "/**\n * The artist representation for the given link\n *\n * @param[in]   link       The Spotify link whose artist you are interested in\n *\n * @return                 The artist representation of the given link\n *                         If the link is not of artist type then NULL is returned\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "link",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_link",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_artist",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_link_as_user",
    "kind": "instance",
    "raw-comment": "/**\n * The user representation for the given link\n *\n * @param[in]   link       The Spotify link whose user you are interested in\n *\n * @return                 The user representation of the given link\n *                         If the link is not of user type then NULL is returned\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "link",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_link",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_user",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_link_add_ref",
    "kind": "instance",
    "raw-comment": "/**\n * Increase the reference count of a link\n *\n * @param[in]   link       The link object\n * @return                 One of the following errors, from ::sp_error\n *                         SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "link",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_link",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_link_release",
    "kind": "instance",
    "raw-comment": "/**\n * Decrease the reference count of a link\n *\n * @param[in]   link       The link object\n * @return                 One of the following errors, from ::sp_error\n *                         SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "link",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_link",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_is_loaded",
    "kind": "instance",
    "raw-comment": "/**\n * Return whether or not the track metadata is loaded.\n *\n * @param[in]   track      The track\n *\n * @return                 True if track is loaded\n *\n * @note  This is equivalent to checking if sp_track_error() not returns SP_ERROR_IS_LOADING.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_error",
    "kind": "instance",
    "raw-comment": "/**\n * Return an error code associated with a track. For example if it could not load\n *\n * @param[in]   track      The track\n *\n * @return                 One of the following errors, from ::sp_error\n *                         SP_ERROR_OK\n *                         SP_ERROR_IS_LOADING\n *                         SP_ERROR_OTHER_PERMANENT\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_offline_get_status",
    "kind": "instance",
    "raw-comment": "/**\n * Return offline status for a track. sp_session_callbacks::metadata_updated() will be invoked when\n * offline status of a track changes\n *\n * @param[in]   track      The track\n *\n * @return                 Stats as described by ::sp_track_offline_status\n *\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_track_offline_status",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_get_availability",
    "kind": "instance",
    "raw-comment": "/**\n * Return availability for a track\n *\n * @param[in]   session    Session\n * @param[in]   track      The track\n *\n * @return                 Availability status, see ::sp_track_availability\n *\n * @note The track must be loaded or this function will always SP_TRACK_AVAILABILITY_UNAVAILABLE\n * @see sp_track_is_loaded()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_track_availability",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_is_local",
    "kind": "instance",
    "raw-comment": "/**\n * Return true if the track is a local file.\n *\n * @param[in]   session    Session\n * @param[in]   track      The track\n *\n * @return                 True if track is a local file.\n *\n * @note The track must be loaded or this function will always return false.\n * @see sp_track_is_loaded()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_is_autolinked",
    "kind": "instance",
    "raw-comment": "/**\n * Return true if the track is autolinked to another track.\n *\n * @param[in]   session    Session\n * @param[in]   track      The track\n *\n * @return                 True if track is autolinked.\n *\n * @note The track must be loaded or this function will always return false.\n * @see sp_track_is_loaded()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_get_playable",
    "kind": "instance",
    "raw-comment": "/**\n * Return the actual track that will be played if the given track is played\n *\n * @param[in]   session    Session\n * @param[in]   track      The track\n *\n * @return                 A track\n *\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_track",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_is_placeholder",
    "kind": "instance",
    "raw-comment": "/**\n * Return true if the track is a placeholder. Placeholder tracks are used\n * to store other objects than tracks in the playlist. Currently this is\n * used in the inbox to store artists, albums and playlists.\n *\n * Use sp_link_create_from_track() to get a link object that points\n * to the real object this \"track\" points to.\n *\n * @param[in]   track      The track\n *\n * @return                 True if track is a placeholder\n *\n * @note Contrary to most functions the track does not have to be\n *       loaded for this function to return correct value\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_is_starred",
    "kind": "instance",
    "raw-comment": "/**\n * Return true if the track is starred by the currently logged in user.\n *\n * @param[in]   session    Session\n * @param[in]   track      The track\n *\n * @return                 True if track is starred.\n *\n * @note The track must be loaded or this function will always return false.\n * @see sp_track_is_loaded()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_set_starred",
    "kind": "instance",
    "raw-comment": "/**\n * Star/Unstar the specified track\n *\n * @param[in]   session    Session\n * @param[in]   tracks     Array of pointer to tracks.\n * @param[in]   num_tracks Length of \\p tracks array\n * @param[in]   star       Starred status of the track\n *\n * @note This will fail silently if playlists are disabled.\n * @see sp_set_playlists_enabled()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "tracks",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "pointer",
              "to": {
                "kind": "named-type",
                "name": "sp_track",
                "qualifiers": []
              },
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "num_tracks",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "star",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "bool",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_num_artists",
    "kind": "instance",
    "raw-comment": "/**\n * The number of artists performing on the specified track\n *\n * @param[in]   track     The track whose number of participating artists you are interested in\n *\n * @return                The number of artists performing on the specified track.\n *                        If no metadata is available for the track yet, this function returns 0.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_artist",
    "kind": "instance",
    "raw-comment": "/**\n * The artist matching the specified index performing on the current track.\n *\n * @param[in]   track      The track whose participating artist you are interested in\n * @param[in]   index      The index for the participating artist. Should be in the interval [0, sp_track_num_artists() - 1]\n *\n * @return                 The participating artist, or NULL if invalid index\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_artist",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_album",
    "kind": "instance",
    "raw-comment": "/**\n * The album of the specified track\n *\n * @param[in]   track      A track object\n *\n * @return                 The album of the given track. You need to increase the refcount\n *                         if you want to keep the pointer around.\n *                         If no metadata is available for the track yet, this function returns 0.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_album",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_name",
    "kind": "instance",
    "raw-comment": "/**\n * The string representation of the specified track's name\n *\n * @param[in]   track      A track object\n *\n * @return                 The string representation of the specified track's name.\n *                         Returned string is valid as long as the album object stays allocated\n *                         and no longer than the next call to sp_session_process_events()\n *                         If no metadata is available for the track yet, this function returns empty string.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "char",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_duration",
    "kind": "instance",
    "raw-comment": "/**\n * The duration, in milliseconds, of the specified track\n *\n * @param[in]   track      A track object\n *\n * @return                 The duration of the specified track, in milliseconds\n *                         If no metadata is available for the track yet, this function returns 0.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_popularity",
    "kind": "instance",
    "raw-comment": "/**\n * Returns popularity for track\n *\n * @param[in]   track      A track object\n *\n * @return                 Popularity in range 0 to 100, 0 if undefined.\n *                         If no metadata is available for the track yet, this function returns 0.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_disc",
    "kind": "instance",
    "raw-comment": "/**\n * Returns the disc number for a track\n *\n * @param[in]   track      A track object\n *\n * @return                 Disc index. Possible values are [1, total number of discs on album]\n *                         This function returns valid data only for tracks appearing in a browse\n *                         artist or browse album result (otherwise returns 0).\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_index",
    "kind": "instance",
    "raw-comment": "/**\n * Returns the position of a track on its disc\n *\n * @param[in]   track      A track object\n *\n * @return                 Track position, starts at 1 (relative the corresponding disc)\n *                         This function returns valid data only for tracks appearing in a browse\n *                         artist or browse album result (otherwise returns 0).\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_localtrack_create",
    "kind": "instance",
    "raw-comment": "/**\n * Returns the newly created local track\n *\n * @param[in]   artist     Name of the artist\n * @param[in]   title      Song title\n * @param[in]   album      Name of the album, or an empty string if not available\n * @param[in]   length      Length in MS, or -1 if not available.\n *\n * @return                 A track.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "artist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "title",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "album",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "length",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_track",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_add_ref",
    "kind": "instance",
    "raw-comment": "/**\n * Increase the reference count of a track\n *\n * @param[in]   track       The track object\n * @return                  One of the following errors, from ::sp_error\n *                          SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_track_release",
    "kind": "instance",
    "raw-comment": "/**\n * Decrease the reference count of a track\n *\n * @param[in]   track       The track object\n * @return                  One of the following errors, from ::sp_error\n *                          SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "track",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_track",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_albumtype",
    "kind": "typedef",
    "raw-comment": "/**\n * Album types\n */",
    "type": {
      "kind": "enum",
      "tag": "",
      "constants": [
        {
          "Name": "SP_ALBUMTYPE_ALBUM",
          "Value": 0,
          "RawComment": "///< Normal album\n"
        },
        {
          "Name": "SP_ALBUMTYPE_SINGLE",
          "Value": 1,
          "RawComment": "///< Single\n"
        },
        {
          "Name": "SP_ALBUMTYPE_COMPILATION",
          "Value": 2,
          "RawComment": "///< Compilation\n"
        },
        {
          "Name": "SP_ALBUMTYPE_UNKNOWN",
          "Value": 3,
          "RawComment": "///< Unknown type\n"
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_album_is_loaded",
    "kind": "instance",
    "raw-comment": "/**\n * Check if the album object is populated with data\n *\n * @param[in]  album       Album object\n * @return True if metadata is present, false if not\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "album",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_album",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_album_is_available",
    "kind": "instance",
    "raw-comment": "/**\n * Return true if the album is available in the current region.\n *\n * @param[in]   album      The album\n *\n * @return                 True if album is available for playback, otherwise false.\n *\n * @note The album must be loaded or this function will always return false.\n * @see sp_album_is_loaded()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "album",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_album",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_album_artist",
    "kind": "instance",
    "raw-comment": "/**\n * Get the artist associated with the given album\n *\n * @param[in]  album       Album object\n * @return A reference to the artist. NULL if the metadata has not been loaded yet\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "album",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_album",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_artist",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_album_cover",
    "kind": "instance",
    "raw-comment": "/**\n * Return image ID representing the album's coverart.\n *\n * @param[in]   album      Album object\n * @param[in]   size       The desired size of the image\n *\n * @return                 ID byte sequence that can be passed to sp_image_create()\n *                         If the album has no image or the metadata for the album is not\n *                         loaded yet, this function returns NULL.\n *\n * @see sp_image_create\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "album",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_album",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "size",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_image_size",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "byte",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_album_name",
    "kind": "instance",
    "raw-comment": "/**\n * Return name of album\n *\n * @param[in]   album      Album object\n *\n * @return                 Name of album.\n *                         Returned string is valid as long as the album object stays allocated\n *                         and no longer than the next call to sp_session_process_events()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "album",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_album",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "char",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_album_year",
    "kind": "instance",
    "raw-comment": "/**\n * Return release year of specified album\n *\n * @param[in]   album      Album object\n *\n * @return                 Release year\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "album",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_album",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_album_type",
    "kind": "instance",
    "raw-comment": "/**\n * Return type of specified album\n *\n * @param[in]   album      Album object\n *\n * @return                 sp_albumtype\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "album",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_album",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_albumtype",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_album_add_ref",
    "kind": "instance",
    "raw-comment": "/**\n * Increase the reference count of an album\n *\n * @param[in]   album       The album object\n * @return                  One of the following errors, from ::sp_error\n *                          SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "album",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_album",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_album_release",
    "kind": "instance",
    "raw-comment": "/**\n * Decrease the reference count of an album\n *\n * @param[in]   album       The album object\n * @return                  One of the following errors, from ::sp_error\n *                          SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "album",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_album",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artist_name",
    "kind": "instance",
    "raw-comment": "/**\n * Return name of artist\n *\n * @param[in]   artist     Artist object\n *\n * @return                 Name of artist.\n *                         Returned string is valid as long as the artist object stays allocated\n *                         and no longer than the next call to sp_session_process_events()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "artist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "char",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artist_is_loaded",
    "kind": "instance",
    "raw-comment": "/**\n * Check if the artist object is populated with data\n *\n * @param[in]   artist     An artist object\n *\n * @return                 True if metadata is present, false if not\n *\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "artist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artist_portrait",
    "kind": "instance",
    "raw-comment": "/**\n * Return portrait for artist\n *\n * @param[in]   artist     The artist object\n * @param[in]   size       The desired size of the image\n *\n * @return                 ID byte sequence that can be passed to sp_image_create()\n *                         If the artist has no image or the metadata for the album is not\n *                         loaded yet, this function returns NULL.\n *\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "artist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "size",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_image_size",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "byte",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artist_add_ref",
    "kind": "instance",
    "raw-comment": "/**\n * Increase the reference count of a artist\n *\n * @param[in]   artist       The artist object\n * @return                   One of the following errors, from ::sp_error\n *                           SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "artist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artist_release",
    "kind": "instance",
    "raw-comment": "/**\n * Decrease the reference count of a artist\n *\n * @param[in]   artist       The artist object\n * @return                   One of the following errors, from ::sp_error\n *                           SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "artist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "albumbrowse_complete_cb",
    "kind": "typedef",
    "raw-comment": "/**\n * The type of a callback used in sp_albumbrowse_create()\n *\n * When the callback is called, the metadata of all tracks belonging to it will have\n * been loaded, so sp_track_is_loaded() will return non-zero. The ::sp_artist of the\n * album will also have been fully loaded.\n *\n * @param[in]   result          The same pointer returned by sp_albumbrowse_create()\n * @param[in]   userdata        The opaque pointer given to sp_albumbrowse_create()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "result",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_albumbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "userdata",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "void",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "void",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_albumbrowse_create",
    "kind": "instance",
    "raw-comment": "/**\n * Initiate a request for browsing an album\n *\n * The user is responsible for freeing the returned album browse using sp_albumbrowse_release(). This can be done in the callback.\n *\n * @param[in]   session         Session object\n * @param[in]   album           Album to be browsed. The album metadata does not have to be loaded\n * @param[in]   callback        Callback to be invoked when browsing has been completed. Pass NULL if you are not interested in this event.\n * @param[in]   userdata        Userdata passed to callback.\n *\n * @return                      Album browse object\n *\n * @see ::albumbrowse_complete_cb\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "album",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_album",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "callback",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "albumbrowse_complete_cb",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "userdata",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "void",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_albumbrowse",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_albumbrowse_is_loaded",
    "kind": "instance",
    "raw-comment": "/**\n * Check if an album browse request is completed\n *\n * @param[in]   alb        Album browse object\n *\n * @return                 True if browsing is completed, false if not\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "alb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_albumbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_albumbrowse_error",
    "kind": "instance",
    "raw-comment": "/**\n* Check if browsing returned an error code.\n*\n* @param[in]   alb        Album browse object\n*\n* @return                 One of the following errors, from ::sp_error\n*                         SP_ERROR_OK\n*                         SP_ERROR_IS_LOADING\n*                         SP_ERROR_OTHER_PERMANENT\n*                         SP_ERROR_OTHER_TRANSIENT\n*/",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "alb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_albumbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_albumbrowse_album",
    "kind": "instance",
    "raw-comment": "/**\n * Given an album browse object, return the pointer to its album object\n *\n * @param[in]   alb        Album browse object\n *\n * @return                 Album object\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "alb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_albumbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_album",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_albumbrowse_artist",
    "kind": "instance",
    "raw-comment": "/**\n * Given an album browse object, return the pointer to its artist object\n *\n * @param[in]   alb        Album browse object\n *\n * @return                 Artist object\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "alb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_albumbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_artist",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_albumbrowse_num_copyrights",
    "kind": "instance",
    "raw-comment": "/**\n * Given an album browse object, return number of copyright strings\n *\n * @param[in]   alb        Album browse object\n *\n * @return                 Number of copyright strings available, 0 if unknown\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "alb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_albumbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_albumbrowse_copyright",
    "kind": "instance",
    "raw-comment": "/**\n * Given an album browse object, return one of its copyright strings\n *\n * @param[in]   alb           Album browse object\n * @param[in]   index         The index for the copyright string. Should be in the interval [0, sp_albumbrowse_num_copyrights() - 1]\n *\n * @return                    Copyright string in UTF-8 format, or NULL if the index is invalid.\n *                            Returned string is valid as long as the album object stays allocated\n *                            and no longer than the next call to sp_session_process_events()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "alb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_albumbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "char",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_albumbrowse_num_tracks",
    "kind": "instance",
    "raw-comment": "/**\n * Given an album browse object, return number of tracks\n *\n * @param[in]   alb         Album browse object\n *\n * @return                  Number of tracks on album\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "alb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_albumbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_albumbrowse_track",
    "kind": "instance",
    "raw-comment": "/**\n * Given an album browse object, return a pointer to one of its tracks\n *\n * @param[in]   alb        Album browse object\n * @param[in]   index      The index for the track. Should be in the interval [0, sp_albumbrowse_num_tracks() - 1]\n *\n * @return                 A track.\n *\n * @see track\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "alb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_albumbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_track",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_albumbrowse_review",
    "kind": "instance",
    "raw-comment": "/**\n * Given an album browse object, return its review\n *\n * @param[in]   alb        Album browse object\n *\n * @return                 Review string in UTF-8 format.\n *                         Returned string is valid as long as the album object stays allocated\n *                         and no longer than the next call to sp_session_process_events()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "alb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_albumbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "char",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_albumbrowse_backend_request_duration",
    "kind": "instance",
    "raw-comment": "/**\n * Return the time (in ms) that was spent waiting for the Spotify backend to serve the request\n *\n * @param[in] alb         Album browse object\n *\n * @return                -1 if the request was served from the local cache\n *                        If the result is not yet loaded the return value is undefined\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "alb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_albumbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_albumbrowse_add_ref",
    "kind": "instance",
    "raw-comment": "/**\n * Increase the reference count of an album browse result\n *\n * @param[in]   alb       The album browse result object\n * @return                One of the following errors, from ::sp_error\n *                        SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "alb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_albumbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_albumbrowse_release",
    "kind": "instance",
    "raw-comment": "/**\n * Decrease the reference count of an album browse result\n *\n * @param[in]   alb       The album browse result object\n * @return                One of the following errors, from ::sp_error\n *                        SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "alb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_albumbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "artistbrowse_complete_cb",
    "kind": "typedef",
    "raw-comment": "/**\n * The type of a callback used in sp_artistbrowse_create()\n *\n * When the callback is called, the metadata of all tracks belonging to it will have\n * been loaded, so sp_track_is_loaded() will return non-zero. The same goes for the\n * similar artist data.\n *\n * @param[in]   result          The same pointer returned by sp_artistbrowse_create()\n * @param[in]   userdata        The opaque pointer given to sp_artistbrowse_create()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "result",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "userdata",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "void",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "void",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artistbrowse_create",
    "kind": "instance",
    "raw-comment": "/**\n * Initiate a request for browsing an artist\n *\n * The user is responsible for freeing the returned artist browse using sp_artistbrowse_release(). This can be done in the callback.\n *\n * @param[in] session         Session object\n * @param[in] artist          Artist to be browsed. The artist metadata does not have to be loaded\n * @param[in] type            Type of data requested, see the sp_artistbrowse_type enum for details\n * @param[in] callback        Callback to be invoked when browsing has been completed. Pass NULL if you are not interested in this event.\n * @param[in] userdata        Userdata passed to callback.\n *\n * @return                    Artist browse object\n *\n * @see ::artistbrowse_complete_cb\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "artist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "type",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_artistbrowse_type",
            "qualifiers": []
          }
        },
        {
          "name": "callback",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "artistbrowse_complete_cb",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "userdata",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "void",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_artistbrowse",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artistbrowse_is_loaded",
    "kind": "instance",
    "raw-comment": "/**\n * Check if an artist browse request is completed\n *\n * @param[in]   arb        Artist browse object\n *\n * @return                 True if browsing is completed, false if not\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "arb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artistbrowse_error",
    "kind": "instance",
    "raw-comment": "/**\n* Check if browsing returned an error code.\n*\n* @param[in]   arb        Artist browse object\n*\n* @return                 One of the following errors, from ::sp_error\n*                         SP_ERROR_OK\n*                         SP_ERROR_IS_LOADING\n*                         SP_ERROR_OTHER_PERMANENT\n*                         SP_ERROR_OTHER_TRANSIENT\n*/",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "arb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artistbrowse_artist",
    "kind": "instance",
    "raw-comment": "/**\n * Given an artist browse object, return a pointer to its artist object\n *\n * @param[in]   arb        Artist browse object\n *\n * @return                 Artist object\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "arb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_artist",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artistbrowse_num_portraits",
    "kind": "instance",
    "raw-comment": "/**\n * Given an artist browse object, return number of portraits available\n *\n * @param[in]   arb        Artist browse object\n *\n * @return                 Number of portraits for given artist\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "arb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artistbrowse_portrait",
    "kind": "instance",
    "raw-comment": "/**\n * Return image ID representing a portrait of the artist\n *\n * @param[in] arb             Artist object\n * @param[in] index           The index of the portrait. Should be in the interval [0, sp_artistbrowse_num_portraits() - 1]\n *\n * @return                    ID byte sequence that can be passed to sp_image_create()\n *\n * @see sp_image_create\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "arb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "byte",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artistbrowse_num_tracks",
    "kind": "instance",
    "raw-comment": "/**\n * Given an artist browse object, return number of tracks\n *\n * @param[in] arb             Artist browse object\n *\n * @return                    Number of tracks for given artist\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "arb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artistbrowse_track",
    "kind": "instance",
    "raw-comment": "/**\n * Given an artist browse object, return one of its tracks\n *\n * @param[in] arb             Album browse object\n * @param[in] index           The index for the track. Should be in the interval [0, sp_artistbrowse_num_tracks() - 1]\n *\n * @return                    A track object, or NULL if the index is out of range.\n *\n * @see track\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "arb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_track",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artistbrowse_num_tophit_tracks",
    "kind": "instance",
    "raw-comment": "/**\n * Given an artist browse object, return number of tophit tracks\n * This is a set of tracks for the artist with highest popularity\n *\n * @param[in] arb             Artist browse object\n *\n * @return                    Number of tophit tracks for given artist\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "arb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artistbrowse_tophit_track",
    "kind": "instance",
    "raw-comment": "/**\n * Given an artist browse object, return one of its tophit tracks\n * This is a set of tracks for the artist with highest popularity\n *\n * @param[in] arb             Album browse object\n * @param[in] index           The index for the track. Should be in the interval [0, sp_artistbrowse_num_tophit_tracks() - 1]\n *\n * @return                    A track object, or NULL if the index is out of range.\n *\n * @see track\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "arb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_track",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artistbrowse_num_albums",
    "kind": "instance",
    "raw-comment": "/**\n * Given an artist browse object, return number of albums\n *\n * @param[in] arb             Artist browse object\n *\n * @return                    Number of albums for given artist\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "arb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artistbrowse_album",
    "kind": "instance",
    "raw-comment": "/**\n * Given an artist browse object, return one of its albums\n *\n * @param[in] arb             Album browse object\n * @param[in] index           The index for the album. Should be in the interval [0, sp_artistbrowse_num_albums() - 1]\n *\n * @return                    A album object, or NULL if the index is out of range.\n *\n * @see album\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "arb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_album",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artistbrowse_num_similar_artists",
    "kind": "instance",
    "raw-comment": "/**\n * Given an artist browse object, return number of similar artists\n *\n * @param[in] arb             Artist browse object\n *\n * @return                    Number of similar artists for given artist\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "arb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artistbrowse_similar_artist",
    "kind": "instance",
    "raw-comment": "/**\n * Given an artist browse object, return a similar artist by index\n *\n * @param[in] arb             Album browse object\n * @param[in] index           The index for the artist. Should be in the interval [0, sp_artistbrowse_num_similar_artists() - 1]\n *\n * @return                    A pointer to an artist object.\n *\n * @see artist\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "arb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_artist",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artistbrowse_biography",
    "kind": "instance",
    "raw-comment": "/**\n * Given an artist browse object, return the artists biography\n *\n * @note This function must be called from the same thread that did sp_session_create()\n * @param[in] arb             Artist browse object\n *\n * @return                    Biography string in UTF-8 format.\n *                            Returned string is valid as long as the album object stays allocated\n *                            and no longer than the next call to sp_session_process_events()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "arb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "char",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artistbrowse_backend_request_duration",
    "kind": "instance",
    "raw-comment": "/**\n * Return the time (in ms) that was spent waiting for the Spotify backend to serve the request\n *\n * @param[in] arb         Artist browse object\n *\n * @return                -1 if the request was served from the local cache\n *                        If the result is not yet loaded the return value is undefined\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "arb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artistbrowse_add_ref",
    "kind": "instance",
    "raw-comment": "/**\n * Increase the reference count of an artist browse result\n *\n * @param[in]   arb       The artist browse result object\n * @return                One of the following errors, from ::sp_error\n *                        SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "arb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_artistbrowse_release",
    "kind": "instance",
    "raw-comment": "/**\n * Decrease the reference count of an artist browse result\n *\n * @param[in]   arb       The artist browse result object\n * @return                One of the following errors, from ::sp_error\n *                        SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "arb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_artistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_imageformat",
    "kind": "typedef",
    "raw-comment": "/**\n * Image format\n */",
    "type": {
      "kind": "enum",
      "tag": "",
      "constants": [
        {
          "Name": "SP_IMAGE_FORMAT_UNKNOWN",
          "Value": -1,
          "RawComment": "///< Unknown image format\n"
        },
        {
          "Name": "SP_IMAGE_FORMAT_JPEG",
          "Value": 0,
          "RawComment": "///< JPEG image\n"
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "image_loaded_cb",
    "kind": "typedef",
    "raw-comment": "/**\n * The type of a callback used to notify the application that an image\n * is done loading.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "image",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_image",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "userdata",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "void",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "void",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_image_create",
    "kind": "instance",
    "raw-comment": "/**\n * Create an image object\n *\n * @param[in]  session    Session\n * @param[in]  image_id   Spotify image ID\n *\n * @return                Pointer to an image object. To free the object, use\n *                        sp_image_release()\n *\n * @see sp_album_cover\n * @see sp_artistbrowse_portrait\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "image_id",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "array",
            "dimension": 20,
            "of": {
              "kind": "named-type",
              "name": "byte",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_image",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_image_create_from_link",
    "kind": "instance",
    "raw-comment": "/**\n * Create an image object from a link\n *\n * @param[in]  session    Session\n * @param[in]  l          Spotify link object. This must be of SP_LINKTYPE_IMAGE type\n *\n * @return                Pointer to an image object. To free the object, use\n *                        sp_image_release()\n *\n * @see sp_image_create\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "l",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_link",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_image",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_image_add_load_callback",
    "kind": "instance",
    "raw-comment": "/**\n * Add a callback that will be invoked when the image is loaded\n *\n * If an image is loaded, and loading fails, the image will behave like an\n * empty image.\n *\n * @param[in]  image      Image object\n * @param[in]  callback   Callback that will be called when image has been\n *                        fetched.\n * @param[in]  userdata   Opaque pointer passed to \\p callback\n *\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "image",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_image",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "callback",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "image_loaded_cb",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "userdata",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "void",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_image_remove_load_callback",
    "kind": "instance",
    "raw-comment": "/**\n * Remove an image load callback previously added with sp_image_add_load_callback()\n *\n * @param[in]  image      Image object\n * @param[in]  callback   Callback that will not be called when image has been\n *                        fetched.\n * @param[in]  userdata   Opaque pointer passed to \\p callback\n * @return                One of the following errors, from ::sp_error\n *                        SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "image",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_image",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "callback",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "image_loaded_cb",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "userdata",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "void",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_image_is_loaded",
    "kind": "instance",
    "raw-comment": "/**\n * Check if an image is loaded. Before the image is loaded, the rest of the\n * methods will behave as if the image is empty.\n *\n * @param[in]  image      Image object\n *\n * @return                True if image is loaded, false otherwise\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "image",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_image",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_image_error",
    "kind": "instance",
    "raw-comment": "/**\n* Check if image retrieval returned an error code.\n*\n* @param[in]   image      Image object\n*\n* @return                 One of the following errors, from ::sp_error\n*                         SP_ERROR_OK\n*                         SP_ERROR_IS_LOADING\n*                         SP_ERROR_OTHER_PERMANENT\n*                         SP_ERROR_OTHER_TRANSIENT\n*/",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "image",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_image",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_image_format",
    "kind": "instance",
    "raw-comment": "/**\n * Get image format\n *\n * @param[in]  image      Image object\n *\n * @return                Image format as described by sp_imageformat\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "image",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_image",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_imageformat",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_image_data",
    "kind": "instance",
    "raw-comment": "/**\n* Get image data\n*\n* @param[in]  image      Image object\n* @param[out] data_size  Size of raw image data\n*\n* @return                Pointer to raw image data\n*/",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "image",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_image",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "data_size",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "size_t",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "void",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_image_image_id",
    "kind": "instance",
    "raw-comment": "/**\n * Get image ID\n *\n * @param[in]  image      Image object\n *\n * @return                Image ID\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "image",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_image",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "byte",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_image_add_ref",
    "kind": "instance",
    "raw-comment": "/**\n * Increase the reference count of an image\n *\n * @param[in]   image     The image object\n * @return                One of the following errors, from ::sp_error\n *                        SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "image",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_image",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_image_release",
    "kind": "instance",
    "raw-comment": "/**\n * Decrease the reference count of an image\n *\n * @param[in]   image     The image object\n * @return                One of the following errors, from ::sp_error\n *                        SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "image",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_image",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "search_complete_cb",
    "kind": "typedef",
    "raw-comment": "/**\n * The type of a callback used in sp_search_create()\n *\n * When this callback is called, the sp_track_is_loaded(), sp_album_is_loaded(),\n * and sp_artist_is_loaded() functions will return non-zero for the objects\n * contained in the search result.\n *\n * @param[in]   result          The same pointer returned by sp_search_create()\n * @param[in]   userdata        The opaque pointer given to sp_search_create()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "result",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "userdata",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "void",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "void",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_create",
    "kind": "instance",
    "raw-comment": "/**\n * Create a search object from the given query\n *\n * @param[in]  session    Session\n * @param[in]  query      Query search string, e.g. 'The Rolling Stones' or 'album:\"The Black Album\"'\n * @param[in]  track_offset     The offset among the tracks of the result\n * @param[in]  track_count      The number of tracks to ask for\n * @param[in]  album_offset     The offset among the albums of the result\n * @param[in]  album_count      The number of albums to ask for\n * @param[in]  artist_offset    The offset among the artists of the result\n * @param[in]  artist_count     The number of artists to ask for\n * @param[in]  playlist_offset  The offset among the playlists of the result\n * @param[in]  playlist_count   The number of playlists to ask for\n * @param[in]  search_type      Type of search, can be used for suggest searches\n * @param[in]  callback   Callback that will be called once the search operation is complete. Pass NULL if you are not interested in this event.\n * @param[in]  userdata   Opaque pointer passed to \\p callback\n *\n * @return                Pointer to a search object. To free the object, use sp_search_release()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "query",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "track_offset",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "track_count",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "album_offset",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "album_count",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "artist_offset",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "artist_count",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "playlist_offset",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "playlist_count",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "search_type",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_search_type",
            "qualifiers": []
          }
        },
        {
          "name": "callback",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "search_complete_cb",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "userdata",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "void",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_search",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_is_loaded",
    "kind": "instance",
    "raw-comment": "/**\n * Get load status for the specified search. Before it is loaded, it will behave as an empty search result.\n *\n * @param[in]  search   Search object\n *\n * @return              True if search is loaded, otherwise false\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_error",
    "kind": "instance",
    "raw-comment": "/**\n* Check if search returned an error code.\n*\n* @param[in]   search     Search object\n*\n* @return                 One of the following errors, from ::sp_error\n*                         SP_ERROR_OK\n*                         SP_ERROR_IS_LOADING\n*                         SP_ERROR_OTHER_PERMANENT\n*                         SP_ERROR_OTHER_TRANSIENT\n*/",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_num_tracks",
    "kind": "instance",
    "raw-comment": "/**\n * Get the number of tracks for the specified search\n *\n * @param[in]  search   Search object\n *\n * @return              The number of tracks for the specified search\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_track",
    "kind": "instance",
    "raw-comment": "/**\n * Return the track at the given index in the given search object\n *\n * @param[in]  search     Search object\n * @param[in]  index      Index of the wanted track. Should be in the interval [0, sp_search_num_tracks() - 1]\n *\n * @return                The track at the given index in the given search object\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_track",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_num_albums",
    "kind": "instance",
    "raw-comment": "/**\n * Get the number of albums for the specified search\n *\n * @param[in]  search   Search object\n *\n * @return              The number of albums for the specified search\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_album",
    "kind": "instance",
    "raw-comment": "/**\n * Return the album at the given index in the given search object\n *\n * @param[in]  search     Search object\n * @param[in]  index      Index of the wanted album. Should be in the interval [0, sp_search_num_albums() - 1]\n *\n * @return                The album at the given index in the given search object\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_album",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_num_playlists",
    "kind": "instance",
    "raw-comment": "/**\n * Get the number of playlists for the specified search\n *\n * @param[in]  search   Search object\n *\n * @return              The number of playlists for the specified search\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_playlist",
    "kind": "instance",
    "raw-comment": "/**\n * Load the playlist at the given index in the given search object\n *\n * @param[in]  search     Search object\n * @param[in]  index      Index of the wanted playlist. Should be in the interval [0, sp_search_num_playlists() - 1]\n *\n * @return                A playlist object. This reference is owned by the caller and should be released with sp_playlist_release()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_playlist",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_playlist_name",
    "kind": "instance",
    "raw-comment": "/**\n * Return the playlist at the given index in the given search object\n *\n * @param[in]  search     Search object\n * @param[in]  index      Index of the wanted playlist. Should be in the interval [0, sp_search_num_playlists() - 1]\n *\n * @return                The playlist name at the given index in the given search object\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "char",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_playlist_uri",
    "kind": "instance",
    "raw-comment": "/**\n * Return the uri of a playlist at the given index in the given search object\n *\n * @param[in]  search     Search object\n * @param[in]  index      Index of the wanted playlist. Should be in the interval [0, sp_search_num_playlists() - 1]\n *\n * @return                The playlist uri at the given index in the given search object\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "char",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_playlist_image_uri",
    "kind": "instance",
    "raw-comment": "/**\n * Return the image_uri of a playlist at the given index in the given search object\n *\n * @param[in]  search     Search object\n * @param[in]  index      Index of the wanted playlist. Should be in the interval [0, sp_search_num_playlists() - 1]\n *\n * @return                The playlist image_uri at the given index in the given search object\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "char",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_num_artists",
    "kind": "instance",
    "raw-comment": "/**\n * Get the number of artists for the specified search\n *\n * @param[in]  search   Search object\n *\n * @return              The number of artists for the specified search\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_artist",
    "kind": "instance",
    "raw-comment": "/**\n * Return the artist at the given index in the given search object\n *\n * @param[in]  search     Search object\n * @param[in]  index      Index of the wanted artist. Should be in the interval [0, sp_search_num_artists() - 1]\n *\n * @return                The artist at the given index in the given search object\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_artist",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_query",
    "kind": "instance",
    "raw-comment": "/**\n * Return the search query for the given search object\n *\n * @param[in]  search     Search object\n *\n * @return                The search query for the given search object\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "char",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_did_you_mean",
    "kind": "instance",
    "raw-comment": "/**\n * Return the \"Did you mean\" query for the given search object\n *\n * @param[in]  search     Search object\n *\n * @return                The \"Did you mean\" query for the given search object, or the empty string if no such info is available\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "char",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_total_tracks",
    "kind": "instance",
    "raw-comment": "/**\n * Return the total number of tracks for the search query - regardless of the interval requested at creation.\n * If this value is larger than the interval specified at creation of the search object, more search results are available.\n * To fetch these, create a new search object with a new interval.\n *\n * @param[in]  search     Search object\n *\n * @return                The total number of tracks matching the original query\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_total_albums",
    "kind": "instance",
    "raw-comment": "/**\n * Return the total number of albums for the search query - regardless of the interval requested at creation.\n * If this value is larger than the interval specified at creation of the search object, more search results are available.\n * To fetch these, create a new search object with a new interval.\n *\n * @param[in]  search     Search object\n *\n * @return                The total number of albums matching the original query\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_total_artists",
    "kind": "instance",
    "raw-comment": "/**\n * Return the total number of artists for the search query - regardless of the interval requested at creation.\n * If this value is larger than the interval specified at creation of the search object, more search results are available.\n * To fetch these, create a new search object with a new interval.\n *\n * @param[in]  search     Search object\n *\n * @return                The total number of artists matching the original query\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_total_playlists",
    "kind": "instance",
    "raw-comment": "/**\n * Return the total number of playlists for the search query - regardless of the interval requested at creation.\n * If this value is larger than the interval specified at creation of the search object, more search results are available.\n * To fetch these, create a new search object with a new interval.\n *\n * @param[in]  search     Search object\n *\n * @return                The total number of playlists matching the original query\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_add_ref",
    "kind": "instance",
    "raw-comment": "/**\n * Increase the reference count of a search result\n *\n * @param[in]   search    The search result object\n * @return                One of the following errors, from ::sp_error\n *                        SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_search_release",
    "kind": "instance",
    "raw-comment": "/**\n * Decrease the reference count of a search result\n *\n * @param[in]   search    The search result object\n * @return                One of the following errors, from ::sp_error\n *                        SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "search",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_search",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_callbacks",
    "kind": "typedef",
    "raw-comment": "/**\n * Playlist callbacks\n *\n * Used to get notifications when playlists are updated.\n * If some callbacks should not be of interest, set them to NULL.\n */",
    "type": {
      "kind": "struct",
      "tag": "sp_playlist_callbacks",
      "fields": [
        {
          "name": "tracks_added",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when one or more tracks have been added to a playlist\n   *\n   * @param[in]  pl         Playlist object\n   * @param[in]  tracks     Array of pointers to track objects\n   * @param[in]  num_tracks Number of entries in \\p tracks\n   * @param[in]  position   Position in the playlist for the first track.\n   * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "pl",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_playlist",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "tracks",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "pointer",
                      "to": {
                        "kind": "named-type",
                        "name": "sp_track",
                        "qualifiers": []
                      },
                      "qualifiers": [
                        "const"
                      ]
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "num_tracks",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "int",
                    "qualifiers": []
                  }
                },
                {
                  "name": "position",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "int",
                    "qualifiers": []
                  }
                },
                {
                  "name": "userdata",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "void",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "tracks_removed",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when one or more tracks have been removed from a playlist\n   *\n   * @param[in]  pl         Playlist object\n   * @param[in]  tracks     Array of positions representing the tracks that were removed\n   * @param[in]  num_tracks Number of entries in \\p tracks\n   * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "pl",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_playlist",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "tracks",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "int",
                      "qualifiers": [
                        "const"
                      ]
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "num_tracks",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "int",
                    "qualifiers": []
                  }
                },
                {
                  "name": "userdata",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "void",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "tracks_moved",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when one or more tracks have been moved within a playlist\n   *\n   * @param[in]  pl         Playlist object\n   * @param[in]  tracks     Array of positions representing the tracks that were moved\n   * @param[in]  num_tracks Number of entries in \\p tracks\n   * @param[in]  position   New position in the playlist for the first track.\n   * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "pl",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_playlist",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "tracks",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "int",
                      "qualifiers": [
                        "const"
                      ]
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "num_tracks",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "int",
                    "qualifiers": []
                  }
                },
                {
                  "name": "new_position",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "int",
                    "qualifiers": []
                  }
                },
                {
                  "name": "userdata",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "void",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "playlist_renamed",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when a playlist has been renamed. sp_playlist_name() can be used to find out the new name\n   *\n   * @param[in]  pl         Playlist object\n   * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "pl",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_playlist",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "userdata",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "void",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "playlist_state_changed",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when state changed for a playlist.\n   *\n   * There are three states that trigger this callback:\n   * - Collaboration for this playlist has been turned on or off\n   * - The playlist started having pending changes, or all pending changes have now been committed\n   * - The playlist started loading, or finished loading\n   *\n   * @param[in]  pl         Playlist object\n   * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()\n   * @sa sp_playlist_is_collaborative\n   * @sa sp_playlist_has_pending_changes\n   * @sa sp_playlist_is_loaded\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "pl",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_playlist",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "userdata",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "void",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "playlist_update_in_progress",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when a playlist is updating or is done updating\n   *\n   * This is called before and after a series of changes are applied to the\n   * playlist. It allows e.g. the user interface to defer updating until the\n   * entire operation is complete.\n   *\n   * @param[in]  pl         Playlist object\n   * @param[in]  done       True iff the update is completed\n   * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "pl",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_playlist",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "done",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "bool",
                    "qualifiers": []
                  }
                },
                {
                  "name": "userdata",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "void",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "playlist_metadata_updated",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when metadata for one or more tracks in a playlist has been updated.\n   *\n   * @param[in]  pl         Playlist object\n   * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "pl",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_playlist",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "userdata",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "void",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "track_created_changed",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when create time and/or creator for a playlist entry changes\n   *\n   * @param[in]  pl         Playlist object\n   * @param[in]  position   Position in playlist\n   * @param[in]  user       User object\n   * @param[in]  time       When entry was created, seconds since the unix epoch.\n   * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "pl",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_playlist",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "position",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "int",
                    "qualifiers": []
                  }
                },
                {
                  "name": "user",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_user",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "when",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "int",
                    "qualifiers": []
                  }
                },
                {
                  "name": "userdata",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "void",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "track_seen_changed",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when seen attribute for a playlist entry changes.\n   *\n   * @param[in]  pl         Playlist object\n   * @param[in]  position   Position in playlist\n   * @param[in]  seen       Set if entry it marked as seen\n   * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "pl",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_playlist",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "position",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "int",
                    "qualifiers": []
                  }
                },
                {
                  "name": "seen",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "bool",
                    "qualifiers": []
                  }
                },
                {
                  "name": "userdata",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "void",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "description_changed",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when playlist description has changed\n   *\n   * @param[in]  pl         Playlist object\n   * @param[in]  desc       New description\n   * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "pl",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_playlist",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "desc",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "char",
                      "qualifiers": [
                        "const"
                      ]
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "userdata",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "void",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "image_changed",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when playlist image has changed\n   *\n   * @param[in]  pl         Playlist object\n   * @param[in]  image      New image\n   * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "pl",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_playlist",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "image",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "byte",
                      "qualifiers": [
                        "const"
                      ]
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "userdata",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "void",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "track_message_changed",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when message attribute for a playlist entry changes.\n   *\n   * @param[in]  pl         Playlist object\n   * @param[in]  position   Position in playlist\n   * @param[in]  message    UTF-8 encoded message\n   * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "pl",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_playlist",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "position",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "int",
                    "qualifiers": []
                  }
                },
                {
                  "name": "message",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "char",
                      "qualifiers": [
                        "const"
                      ]
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "userdata",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "void",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "subscribers_changed",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when playlist subscribers changes (count or list of names)\n   *\n   * @param[in]  pl         Playlist object\n   * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "pl",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_playlist",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "userdata",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "void",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_is_loaded",
    "kind": "instance",
    "raw-comment": "/**\n * Get load status for the specified playlist. If it's false, you have to wait until\n * playlist_state_changed happens, and check again if is_loaded has changed\n *\n * @param[in]  playlist   Playlist object\n *\n * @return                True if playlist is loaded, otherwise false\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_add_callbacks",
    "kind": "instance",
    "raw-comment": "/**\n * Register interest in the given playlist\n *\n * Here is a snippet from \\c jukebox.c:\n * @dontinclude jukebox.c\n * @skipline sp_playlist_add_callbacks\n *\n * @param[in]  playlist   Playlist object\n * @param[in]  callbacks  Callbacks, see #sp_playlist_callbacks\n * @param[in]  userdata   Userdata to be passed to callbacks\n * @sa sp_playlist_remove_callbacks\n *\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "callbacks",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist_callbacks",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "userdata",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "void",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_remove_callbacks",
    "kind": "instance",
    "raw-comment": "/**\n * Unregister interest in the given playlist\n *\n * The combination of (\\p callbacks, \\p userdata) is used to find the entry to be removed\n *\n * Here is a snippet from \\c jukebox.c:\n * @dontinclude jukebox.c\n * @skipline sp_playlist_remove_callbacks\n *\n * @param[in]  playlist   Playlist object\n * @param[in]  callbacks  Callbacks, see #sp_playlist_callbacks\n * @param[in]  userdata   Userdata to be passed to callbacks\n * @sa sp_playlist_add_callbacks\n * @return                One of the following errors, from ::sp_error\n *                        SP_ERROR_OK\n *\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "callbacks",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist_callbacks",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "userdata",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "void",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_num_tracks",
    "kind": "instance",
    "raw-comment": "/**\n * Return number of tracks in the given playlist\n *\n * @param[in]  playlist   Playlist object\n *\n * @return                The number of tracks in the playlist\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_track",
    "kind": "instance",
    "raw-comment": "/**\n * Return the track at the given index in a playlist\n *\n * @param[in]  playlist   Playlist object\n * @param[in]  index      Index into playlist container. Should be in the interval [0, sp_playlist_num_tracks() - 1]\n *\n * @return                The track at the given index\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_track",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_track_create_time",
    "kind": "instance",
    "raw-comment": "/**\n * Return when the given index was added to the playlist\n *\n * @param[in]  playlist   Playlist object\n * @param[in]  index      Index into playlist container. Should be in the interval [0, sp_playlist_num_tracks() - 1]\n *\n * @return                Time, Seconds since unix epoch.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_track_creator",
    "kind": "instance",
    "raw-comment": "/**\n * Return user that added the given index in the playlist\n *\n * @param[in]  playlist   Playlist object\n * @param[in]  index      Index into playlist container. Should be in the interval [0, sp_playlist_num_tracks() - 1]\n *\n * @return                User object\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_user",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_track_seen",
    "kind": "instance",
    "raw-comment": "/**\n * Return if a playlist entry is marked as seen or not\n *\n * @param[in]  playlist   Playlist object\n * @param[in]  index      Index into playlist container. Should be in the interval [0, sp_playlist_num_tracks() - 1]\n *\n * @return                Seen state\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_track_set_seen",
    "kind": "instance",
    "raw-comment": "/**\n * Set seen status of a playlist entry\n *\n * @param[in]  playlist   Playlist object\n * @param[in]  index      Index into playlist container. Should be in the interval [0, sp_playlist_num_tracks() - 1]\n * @param[in]  seen       Seen status to be set\n *\n * @return     error     One of the following errors, from ::sp_error\n *                       SP_ERROR_OK\n *                       SP_ERROR_INDEX_OUT_OF_RANGE\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "seen",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "bool",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_track_message",
    "kind": "instance",
    "raw-comment": "/**\n * Return a message attached to a playlist item. Typically used on inbox.\n *\n * @param[in]  playlist   Playlist object\n * @param[in]  index      Index into playlist container. Should be in the interval [0, sp_playlist_num_tracks() - 1]\n *\n * @return                UTF-8 encoded message, or NULL if no message is present\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "char",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_name",
    "kind": "instance",
    "raw-comment": "/**\n * Return name of given playlist\n *\n * @param[in]  playlist   Playlist object\n *\n * @return                The name of the given playlist\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "char",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_rename",
    "kind": "instance",
    "raw-comment": "/**\n * Rename the given playlist\n * The name must not consist of only spaces and it must be shorter than 256 characters.\n *\n * @param[in]  playlist   Playlist object\n * @param[in]  new_name   New name for playlist\n *\n * @return                One of the following errors, from ::sp_error\n *                        SP_ERROR_OK\n *                        SP_ERROR_INVALID_INDATA\n *                        SP_ERROR_PERMISSION_DENIED\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "new_name",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_owner",
    "kind": "instance",
    "raw-comment": "/**\n * Return a pointer to the user for the given playlist\n *\n * @param[in]  playlist   Playlist object\n *\n * @return                User object\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_user",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_is_collaborative",
    "kind": "instance",
    "raw-comment": "/**\n * Return collaborative status for a playlist.\n *\n * A playlist in collaborative state can be modifed by all users, not only the user owning the list\n *\n * @param[in]  playlist   Playlist object\n *\n * @return                true if playlist is collaborative, otherwise false\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_set_collaborative",
    "kind": "instance",
    "raw-comment": "/**\n * Set collaborative status for a playlist.\n *\n * A playlist in collaborative state can be modified by all users, not only the user owning the list\n *\n * @param[in]  playlist       Playlist object\n * @param[in]  collaborative  True or false\n * @return                    One of the following errors, from ::sp_error\n *                            SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "collaborative",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "bool",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_set_autolink_tracks",
    "kind": "instance",
    "raw-comment": "/**\n * Set autolinking state for a playlist.\n *\n * If a playlist is autolinked, unplayable tracks will be made playable\n * by linking them to other Spotify tracks, where possible.\n *\n * @param[in]  playlist       Playlist object\n * @param[in]  link           True or false\n * @return                    One of the following errors, from ::sp_error\n *                            SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "link",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "bool",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_get_description",
    "kind": "instance",
    "raw-comment": "/**\n * Get description for a playlist\n *\n * @param[in]  playlist       Playlist object\n *\n * @return                    Playlist description or NULL if unset\n *\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "char",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_get_image",
    "kind": "instance",
    "raw-comment": "/**\n * Get description for a playlist\n *\n * @param[in]  playlist       Playlist object\n * @param[out] image          20 byte image id\n\n * @return                    TRUE if playlist has an image, FALSE if not\n *\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "image",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "array",
            "dimension": 20,
            "of": {
              "kind": "named-type",
              "name": "byte",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_has_pending_changes",
    "kind": "instance",
    "raw-comment": "/**\n * Check if a playlist has pending changes\n *\n * Pending changes are local changes that have not yet been acknowledged by the server.\n *\n * @param[in]  playlist       Playlist object\n *\n * @return                    A flag representing if there are pending changes or not\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_add_tracks",
    "kind": "instance",
    "raw-comment": "/**\n * Add tracks to a playlist\n *\n * @param[in]  playlist       Playlist object\n * @param[in]  tracks         Array of pointer to tracks.\n * @param[in]  num_tracks     Length of \\p tracks array\n * @param[in]  position       Start position in playlist where to insert the tracks\n * @param[in]  session        Your session object\n *\n * @return                One of the following errors, from ::sp_error\n *                        SP_ERROR_OK\n *                        SP_ERROR_INVALID_INDATA - position is > current playlist length\n *                        SP_ERROR_PERMISSION_DENIED\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "tracks",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "pointer",
              "to": {
                "kind": "named-type",
                "name": "sp_track",
                "qualifiers": []
              },
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "num_tracks",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "position",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_remove_tracks",
    "kind": "instance",
    "raw-comment": "/**\n * Remove tracks from a playlist\n *\n * @param[in]  playlist       Playlist object\n * @param[in]  tracks         Array of pointer to track indices.\n *                            A certain track index should be present at most once, e.g. [0, 1, 2] is valid indata,\n *                            whereas [0, 1, 1] is invalid.\n * @param[in]  num_tracks     Length of \\p tracks array\n *\n * @return                    One of the following errors, from ::sp_error\n *                            SP_ERROR_OK\n *                            SP_ERROR_PERMISSION_DENIED\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "tracks",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "int",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "num_tracks",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_reorder_tracks",
    "kind": "instance",
    "raw-comment": "/**\n * Move tracks in playlist\n *\n * @param[in]  playlist       Playlist object\n * @param[in]  tracks         Array of pointer to track indices to be moved.\n *                            A certain track index should be present at most once, e.g. [0, 1, 2] is valid indata,\n *                            whereas [0, 1, 1] is invalid.\n * @param[in]  num_tracks     Length of \\p tracks array\n * @param[in]  new_position   New position for tracks\n *\n * @return                    One of the following errors, from ::sp_error\n *                            SP_ERROR_OK\n *                            SP_ERROR_INVALID_INDATA - position is > current playlist length\n *                            SP_ERROR_PERMISSION_DENIED\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "tracks",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "int",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "num_tracks",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "new_position",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_num_subscribers",
    "kind": "instance",
    "raw-comment": "/**\n * Return number of subscribers for a given playlist\n *\n * @param[in]  playlist       Playlist object\n *\n * @return     Number of subscribers\n *\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": [
          "unsigned"
        ]
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_subscribers",
    "kind": "instance",
    "raw-comment": "/**\n * Return subscribers for a playlist\n *\n * @param[in]  playlist       Playlist object\n *\n * @return     sp_subscribers struct with array of canonical usernames.\n *             This object should be free'd using sp_playlist_subscribers_free()\n *\n * @note       The count returned for this function may be less than those\n *             returned by sp_playlist_num_subscribers(). Spotify does not\n *             track each user subscribed to a playlist for playlist with\n *             many (>500) subscribers.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_subscribers",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_subscribers_free",
    "kind": "instance",
    "raw-comment": "/**\n * Free object returned from sp_playlist_subscribers()\n *\n * @param[in] subscribers   Subscribers object\n * @return                    One of the following errors, from ::sp_error\n *                            SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "subscribers",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_subscribers",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_update_subscribers",
    "kind": "instance",
    "raw-comment": "/**\n * Ask library to update the subscription count for a playlist\n *\n * When the subscription info has been fetched from the Spotify backend\n * the playlist subscribers_changed() callback will be invoked.\n * In that callback use sp_playlist_num_subscribers() and/or\n * sp_playlist_subscribers() to get information about the subscribers.\n * You can call those two functions anytime you want but the information\n * might not be up to date in such cases\n *\n * @param[in]  session        Session object\n * @param[in]  playlist       Playlist object\n * @return                    One of the following errors, from ::sp_error\n *                            SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_is_in_ram",
    "kind": "instance",
    "raw-comment": "/**\n * Return whether a playlist is loaded in RAM (as opposed to only\n * stored on disk)\n *\n * @param[in]  session        Session object\n * @param[in]  playlist       Playlist object\n *\n * @return True iff playlist is in RAM, False otherwise\n *\n * @note       When a playlist is no longer in RAM it will appear empty.\n *             However, libspotify will retain information about the\n *             list metadata  (owner, title, picture, etc) in RAM.\n *             There is one caveat tough: If libspotify has never seen the\n *             playlist before this metadata will also be unset.\n *             In order for libspotify to get the metadata the playlist\n *             needs to be loaded at least once.\n *             In order words, if libspotify starts with an empty playlist\n *             cache and the application has set 'initially_unload_playlists'\n *             config parameter to True all playlists will be empty.\n *             It will not be possible to generate URI's to the playlists\n *             nor extract playlist title until the application calls\n *             sp_playlist_set_in_ram(..., true). So an application\n *             that needs to stay within a low memory profile would need to\n *             cycle thru all new playlists in order to extract metadata.\n *\n *             The easiest way to detect this case is when\n *             sp_playlist_is_in_ram() returns false and\n *             sp_link_create_from_playlist() returns NULL\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_set_in_ram",
    "kind": "instance",
    "raw-comment": "/**\n * Return whether a playlist is loaded in RAM (as opposed to only\n * stored on disk)\n *\n * @param[in]  session        Session object\n * @param[in]  playlist       Playlist object\n * @param[in]  in_ram         Controls whether or not to keep the list in RAM\n * @return                    One of the following errors, from ::sp_error\n *                            SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "in_ram",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "bool",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_create",
    "kind": "instance",
    "raw-comment": "/**\n * Load an already existing playlist without adding it to a playlistcontainer.\n *\n * @param[in]  session        Session object\n * @param[in]  link           Link object referring to a playlist\n *\n * @return     A playlist. The reference is owned by the caller and should be released with sp_playlist_release()\n *\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "link",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_link",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_playlist",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_set_offline_mode",
    "kind": "instance",
    "raw-comment": "/**\n * Mark a playlist to be synchronized for offline playback.\n * The playlist must be in the users playlistcontainer\n *\n * @param[in]  session        Session object\n * @param[in]  playlist       Playlist object\n * @param[in]  offline        True iff playlist should be offline, false otherwise\n * @return                    One of the following errors, from ::sp_error\n *                            SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "offline",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "bool",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_get_offline_status",
    "kind": "instance",
    "raw-comment": "/**\n * Get offline status for a playlist\n *\n * @param[in]  session        Session object\n * @param[in]  playlist       Playlist object\n *\n * @return sp_playlist_offline_status\n *\n * @see When in SP_PLAYLIST_OFFLINE_STATUS_DOWNLOADING mode the\n *      sp_playlist_get_offline_download_completed() method can be used to query\n *      progress of the download\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_playlist_offline_status",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_get_offline_download_completed",
    "kind": "instance",
    "raw-comment": "/**\n * Get download progress for an offline playlist\n *\n * @param[in]  session        Session object\n * @param[in]  playlist       Playlist object\n *\n * @return Value from 0 - 100 that indicates amount of playlist that is downloaded\n * or 0 if the playlist is not in the SP_PLAYLIST_OFFLINE_STATUS_DOWNLOADING mode.\n *\n * @see sp_playlist_offline_status()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_add_ref",
    "kind": "instance",
    "raw-comment": "/**\n * Increase the reference count of a playlist\n *\n * @param[in]   playlist       The playlist object\n * @return                     One of the following errors, from ::sp_error\n *                             SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlist_release",
    "kind": "instance",
    "raw-comment": "/**\n * Decrease the reference count of a playlist\n *\n * @param[in]   playlist       The playlist object\n * @return                     One of the following errors, from ::sp_error\n *                             SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlistcontainer_callbacks",
    "kind": "typedef",
    "raw-comment": "/**\n * Playlist container callbacks.\n * If some callbacks should not be of interest, set them to NULL.\n *\n * @see sp_playlistcontainer_add_callbacks\n * @see sp_playlistcontainer_remove_callbacks\n */",
    "type": {
      "kind": "struct",
      "tag": "sp_playlistcontainer_callbacks",
      "fields": [
        {
          "name": "playlist_added",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when a new playlist has been added to the playlist container.\n   *\n   * @param[in]  pc         Playlist container\n   * @param[in]  playlist   Playlist object.\n   * @param[in]  position   Position in list\n   * @param[in]  userdata   Userdata as set in sp_playlistcontainer_add_callbacks()\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "pc",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_playlistcontainer",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "playlist",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_playlist",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "position",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "int",
                    "qualifiers": []
                  }
                },
                {
                  "name": "userdata",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "void",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "playlist_removed",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when a new playlist has been removed from playlist container\n   *\n   * @param[in]  pc         Playlist container\n   * @param[in]  playlist   Playlist object.\n   * @param[in]  position   Position in list\n   * @param[in]  userdata   Userdata as set in sp_playlistcontainer_add_callbacks()\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "pc",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_playlistcontainer",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "playlist",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_playlist",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "position",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "int",
                    "qualifiers": []
                  }
                },
                {
                  "name": "userdata",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "void",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "playlist_moved",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when a playlist has been moved in the playlist container\n   *\n   * @param[in]  pc         Playlist container\n   * @param[in]  playlist   Playlist object.\n   * @param[in]  position   Previous position in playlist container list\n   * @param[in]  new_position   New position in playlist container list\n   * @param[in]  userdata   Userdata as set in sp_playlistcontainer_add_callbacks()\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "pc",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_playlistcontainer",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "playlist",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_playlist",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "position",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "int",
                    "qualifiers": []
                  }
                },
                {
                  "name": "new_position",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "named-type",
                    "name": "int",
                    "qualifiers": []
                  }
                },
                {
                  "name": "userdata",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "void",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "container_loaded",
          "kind": "instance",
          "raw-comment": "/**\n   * Called when the playlist container is loaded\n   *\n   * @param[in]  pc         Playlist container\n   * @param[in]  userdata   Userdata as set in sp_playlistcontainer_add_callbacks()\n   */",
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "function",
              "arguments": [
                {
                  "name": "pc",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "sp_playlistcontainer",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                },
                {
                  "name": "userdata",
                  "kind": "instance",
                  "raw-comment": null,
                  "type": {
                    "kind": "pointer",
                    "to": {
                      "kind": "named-type",
                      "name": "void",
                      "qualifiers": []
                    },
                    "qualifiers": []
                  }
                }
              ],
              "returning": {
                "kind": "named-type",
                "name": "void",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlistcontainer_add_callbacks",
    "kind": "instance",
    "raw-comment": "/**\n * Register interest in changes to a playlist container\n *\n * @param[in]  pc        Playlist container\n * @param[in]  callbacks Callbacks, see sp_playlistcontainer_callbacks\n * @param[in]  userdata  Opaque value passed to callbacks.\n *\n * @note Every sp_playlistcontainer_add_callbacks() needs to be paired with a corresponding\n *       sp_playlistcontainer_remove_callbacks() that is invoked before releasing the\n *       last reference you own for the container. In other words, you must make sure\n *       to have removed all the callbacks before the container gets destroyed.\n *\n * @sa sp_session_playlistcontainer()\n * @sa sp_playlistcontainer_remove_callbacks\n * @return              One of the following errors, from ::sp_error\n *                      SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "pc",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlistcontainer",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "callbacks",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlistcontainer_callbacks",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "userdata",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "void",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlistcontainer_remove_callbacks",
    "kind": "instance",
    "raw-comment": "/**\n * Unregister interest in changes to a playlist container\n *\n * @param[in]  pc        Playlist container\n * @param[in]  callbacks Callbacks, see sp_playlistcontainer_callbacks\n * @param[in]  userdata  Opaque value passed to callbacks.\n *\n * @sa sp_session_playlistcontainer()\n * @sa sp_playlistcontainer_add_callbacks\n * @return              One of the following errors, from ::sp_error\n *                      SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "pc",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlistcontainer",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "callbacks",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlistcontainer_callbacks",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "userdata",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "void",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlistcontainer_num_playlists",
    "kind": "instance",
    "raw-comment": "/**\n * Return the number of playlists in the given playlist container\n *\n * @param[in]  pc        Playlist container\n *\n * @return               Number of playlists, -1 if undefined\n *\n * @sa sp_session_playlistcontainer()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "pc",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlistcontainer",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlistcontainer_is_loaded",
    "kind": "instance",
    "raw-comment": "/**\n * Return true if the playlistcontainer is fully loaded\n *\n * @param[in]  pc        Playlist container\n *\n * @return               True if container is loaded\n *\n * @note The container_loaded callback will be invoked when this flips to true\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "pc",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlistcontainer",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlistcontainer_playlist",
    "kind": "instance",
    "raw-comment": "/**\n * Return a pointer to the playlist at a specific index\n *\n * @param[in]  pc        Playlist container\n * @param[in]  index     Index in playlist container. Should be in the interval [0, sp_playlistcontainer_num_playlists() - 1]\n *\n * @return               The playlist object\n *\n * @sa sp_session_playlistcontainer()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "pc",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlistcontainer",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_playlist",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlistcontainer_playlist_type",
    "kind": "instance",
    "raw-comment": "/**\n * Return the type of the playlist at a @a index\n *\n * @param[in]  pc        Playlist container\n * @param[in]  index     Index in playlist container. Should be in the interval [0, sp_playlistcontainer_num_playlists() - 1]\n *\n * @return               Type of the playlist, @see sp_playlist_type\n *\n * @sa sp_session_playlistcontainer()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "pc",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlistcontainer",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_playlist_type",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlistcontainer_playlist_folder_name",
    "kind": "instance",
    "raw-comment": "/**\n * Return the folder name at @a index\n *\n * @param[in]  pc           Playlist container\n * @param[in]  index        Index in playlist container. Should be in the interval [0, sp_playlistcontainer_num_playlists() - 1].\n *                          Index should point at a start-folder entry, otherwise the empty string is written to buffer.\n * @param[in]  buffer       Pointer to char[] where to store folder name\n * @param[in]  buffer_size  Size of array\n *\n * @return                  One of the following errors, from ::sp_error\n *                          SP_ERROR_OK\n *                          SP_ERROR_INDEX_OUT_OF_RANGE\n *\n * @sa sp_session_playlistcontainer()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "pc",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlistcontainer",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "buffer",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "buffer_size",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlistcontainer_playlist_folder_id",
    "kind": "instance",
    "raw-comment": "/**\n * Return the folder id at @a index\n *\n * @param[in]  pc        Playlist container\n * @param[in]  index     Index in playlist container. Should be in the interval [0, sp_playlistcontainer_num_playlists() - 1]\n *\n * @return               The group ID of the folder. Returns 0 on index out of range, pc being NULL or indexed item not being a folder\n *\n * @sa sp_session_playlistcontainer()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "pc",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlistcontainer",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_uint64",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlistcontainer_add_new_playlist",
    "kind": "instance",
    "raw-comment": "/**\n * Add an empty playlist at the end of the playlist container.\n * The name must not consist of only spaces and it must be shorter than 256 characters.\n *\n * @param[in]  pc        Playlist container\n * @param[in]  name      Name of new playlist\n *\n * @return               Pointer to the new playlist. Can be NULL if the operation fails.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "pc",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlistcontainer",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "name",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_playlist",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlistcontainer_add_playlist",
    "kind": "instance",
    "raw-comment": "/**\n * Add an existing playlist at the end of the given playlist container\n *\n * @param[in]  pc        Playlist container\n * @param[in]  link      Link object pointing to a playlist\n *\n * @return               Pointer to the new playlist. Will be NULL if the playlist already exists.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "pc",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlistcontainer",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "link",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_link",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_playlist",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlistcontainer_remove_playlist",
    "kind": "instance",
    "raw-comment": "/**\n * Remove playlist at index from the given playlist container\n *\n * @param[in]  pc        Playlist container\n * @param[in]  index     Index of playlist to be removed\n *\n * @return     error     One of the following errors, from ::sp_error\n *                       SP_ERROR_OK\n *                       SP_ERROR_INDEX_OUT_OF_RANGE\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "pc",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlistcontainer",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlistcontainer_move_playlist",
    "kind": "instance",
    "raw-comment": "/**\n * Move a playlist in the playlist container\n *\n * @param[in]  pc           Playlist container\n * @param[in]  index        Index of playlist to be moved\n * @param[in]  new_position New position for the playlist\n * @param[in]  dry_run      Do not execute the move, only check if it possible\n\n * @return     error        One of the following errors, from ::sp_error\n *                          SP_ERROR_OK\n *                          SP_ERROR_INDEX_OUT_OF_RANGE\n *                          SP_ERROR_INVALID_INDATA - If trying to move a folder into itself\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "pc",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlistcontainer",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "new_position",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "dry_run",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "bool",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlistcontainer_add_folder",
    "kind": "instance",
    "raw-comment": "/**\n * Add a playlist folder\n *\n * @param[in]  pc           Playlist container\n * @param[in]  index        Position of SP_PLAYLIST_TYPE_START_FOLDER entry\n * @param[in]  name         Name of group\n\n * @return     error        One of the following errors, from ::sp_error\n *                          SP_ERROR_OK\n *                          SP_ERROR_INDEX_OUT_OF_RANGE\n *\n * @note This operation will actually create two playlists. One of\n * type SP_PLAYLIST_TYPE_START_FOLDER and immediately following a\n * SP_PLAYLIST_TYPE_END_FOLDER one.\n *\n * To remove a playlist folder both of these must be deleted or the list\n * will be left in an inconsistant state.\n *\n * There is no way to rename a playlist folder. Instead you need to remove\n * the folder and recreate it again.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "pc",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlistcontainer",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "name",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlistcontainer_owner",
    "kind": "instance",
    "raw-comment": "/**\n * Return a pointer to the user object of the owner.\n *\n * @param[in]  pc   Playlist container.\n * @return          The user object or NULL if unknown or none.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "pc",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlistcontainer",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_user",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlistcontainer_add_ref",
    "kind": "instance",
    "raw-comment": "/**\n * Increase reference count on playlistconatiner object\n *\n * @param[in]  pc   Playlist container.\n * @return          One of the following errors, from ::sp_error\n *                  SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "pc",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlistcontainer",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlistcontainer_release",
    "kind": "instance",
    "raw-comment": "/**\n * Release reference count on playlistconatiner object\n *\n * @param[in]  pc   Playlist container.\n * @return          One of the following errors, from ::sp_error\n *                  SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "pc",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlistcontainer",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlistcontainer_get_unseen_tracks",
    "kind": "instance",
    "raw-comment": "/**\n * Get the number of new tracks in a playlist since the corresponding\n * function sp_playlistcontainer_clear_unseen_tracks() was called. The\n * function always returns the number of new tracks, and fills the\n * \\p tracks array with the new tracks, but not more than specified in\n * \\p num_tracks. The function will return a negative value on failure.\n *\n * @param[in]  pc         Playlist container.\n * @param[in]  playlist   Playlist object.\n * @param[out] tracks     Array of pointer to new tracks (maybe NULL)\n * @param[in]  num_tracks Size of tracks array\n * @return     Returns the number of unseen tracks\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "pc",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlistcontainer",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "tracks",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "pointer",
              "to": {
                "kind": "named-type",
                "name": "sp_track",
                "qualifiers": []
              },
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "num_tracks",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_playlistcontainer_clear_unseen_tracks",
    "kind": "instance",
    "raw-comment": "/**\n * Clears a playlist from unseen tracks, so that next call to sp_playlistcontainer_get_unseen_tracks() will return 0 until a new track is added to the \\p playslist.\n *\n * @param[in]  pc       Playlist container.\n * @param[in]  playlist   Playlist object.\n * @return     Returns 0 on success and -1 on failure.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "pc",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlistcontainer",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "playlist",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_playlist",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_relation_type",
    "kind": "typedef",
    "raw-comment": "/**\n * User relation type\n */",
    "type": {
      "kind": "enum",
      "tag": "sp_relation_type",
      "constants": [
        {
          "Name": "SP_RELATION_TYPE_UNKNOWN",
          "Value": 0,
          "RawComment": "///< Not yet known\n"
        },
        {
          "Name": "SP_RELATION_TYPE_NONE",
          "Value": 1,
          "RawComment": "///< No relation\n"
        },
        {
          "Name": "SP_RELATION_TYPE_UNIDIRECTIONAL",
          "Value": 2,
          "RawComment": "///< The currently logged in user is following this uer\n"
        },
        {
          "Name": "SP_RELATION_TYPE_BIDIRECTIONAL",
          "Value": 3,
          "RawComment": "///< Bidirectional friendship established\n"
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_user_canonical_name",
    "kind": "instance",
    "raw-comment": "/**\n * Get a pointer to a string representing the user's canonical username.\n *\n * @param[in]   user         The Spotify user whose canonical username you would like a string representation of\n *\n * @return                   A string representing the canonical username.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "user",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_user",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "char",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_user_display_name",
    "kind": "instance",
    "raw-comment": "/**\n * Get a pointer to a string representing the user's displayable username.\n * If there is no difference between the canonical username and the display name,\n * or if the library does not know about the display name yet, the canonical username will\n * be returned.\n *\n * @param[in]   user         The Spotify user whose displayable username you would like a string representation of\n *\n * @return                   A string\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "user",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_user",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "char",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_user_is_loaded",
    "kind": "instance",
    "raw-comment": "/**\n * Get load status for a user object. Before it is loaded, only the user's canonical username\n * is known.\n *\n * @param[in]   user         Spotify user object\n *\n * @return                   True if user object is loaded, otherwise false\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "user",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_user",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_user_add_ref",
    "kind": "instance",
    "raw-comment": "/**\n * Increase the reference count of an user\n *\n * @param[in]   user       The user object\n * @return                 One of the following errors, from ::sp_error\n *                         SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "user",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_user",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_user_release",
    "kind": "instance",
    "raw-comment": "/**\n * Decrease the reference count of an user\n *\n * @param[in]   user       The user object\n * @return                 One of the following errors, from ::sp_error\n *                         SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "user",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_user",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_toplisttype",
    "kind": "typedef",
    "raw-comment": "/**\n * Toplist types\n */",
    "type": {
      "kind": "enum",
      "tag": "",
      "constants": [
        {
          "Name": "SP_TOPLIST_TYPE_ARTISTS",
          "Value": 0,
          "RawComment": "///< Top artists\n"
        },
        {
          "Name": "SP_TOPLIST_TYPE_ALBUMS",
          "Value": 1,
          "RawComment": "///< Top albums\n"
        },
        {
          "Name": "SP_TOPLIST_TYPE_TRACKS",
          "Value": 2,
          "RawComment": "///< Top tracks\n"
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "sp_toplistregion",
    "kind": "typedef",
    "raw-comment": "/**\n * Special toplist regions\n */",
    "type": {
      "kind": "enum",
      "tag": "",
      "constants": [
        {
          "Name": "SP_TOPLIST_REGION_EVERYWHERE",
          "Value": 0,
          "RawComment": "///< Global toplist\n"
        },
        {
          "Name": "SP_TOPLIST_REGION_USER",
          "Value": 1,
          "RawComment": "///< Toplist for a given user\n"
        }
      ],
      "qualifiers": []
    }
  },
  {
    "name": "toplistbrowse_complete_cb",
    "kind": "typedef",
    "raw-comment": "/**\n * The type of a callback used in sp_toplistbrowse_create()\n *\n * When the callback is called, the metadata of all tracks belonging to it will have\n * been loaded, so sp_track_is_loaded() will return non-zero. The same goes for the\n * similar toplist data.\n *\n * @param[in]   result          The same pointer returned by sp_toplistbrowse_create()\n * @param[in]   userdata        The opaque pointer given to sp_toplistbrowse_create()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "result",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_toplistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "userdata",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "void",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "void",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_toplistbrowse_create",
    "kind": "instance",
    "raw-comment": "/**\n * Initiate a request for browsing an toplist\n *\n * The user is responsible for freeing the returned toplist browse using sp_toplistbrowse_release(). This can be done in the callback.\n *\n * @param[in]   session         Session object\n * @param[in]   type            Type of toplist to be browsed. see the sp_toplisttype enum for possible values\n * @param[in]   region          Region. see sp_toplistregion enum. Country specific regions are coded as two chars in an integer.\n *                              Sweden would correspond to 'S' << 8 | 'E'\n * @param[in]   username        If region is SP_TOPLIST_REGION_USER this specifies which user to get toplists for. NULL means the logged in user.\n * @param[in]   callback        Callback to be invoked when browsing has been completed. Pass NULL if you are not interested in this event.\n * @param[in]   userdata        Userdata passed to callback.\n *\n * @return                      Toplist browse object\n *\n * @see ::toplistbrowse_complete_cb\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "type",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_toplisttype",
            "qualifiers": []
          }
        },
        {
          "name": "region",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "sp_toplistregion",
            "qualifiers": []
          }
        },
        {
          "name": "username",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "callback",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "toplistbrowse_complete_cb",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "userdata",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "void",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_toplistbrowse",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_toplistbrowse_is_loaded",
    "kind": "instance",
    "raw-comment": "/**\n * Check if an toplist browse request is completed\n *\n * @param[in]   tlb        Toplist browse object\n *\n * @return                 True if browsing is completed, false if not\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "tlb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_toplistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "bool",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_toplistbrowse_error",
    "kind": "instance",
    "raw-comment": "/**\n* Check if browsing returned an error code.\n*\n* @param[in]   tlb        Toplist browse object\n*\n* @return                 One of the following errors, from ::sp_error\n*                         SP_ERROR_OK\n*                         SP_ERROR_IS_LOADING\n*                         SP_ERROR_OTHER_PERMANENT\n*                         SP_ERROR_OTHER_TRANSIENT\n*/",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "tlb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_toplistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_toplistbrowse_add_ref",
    "kind": "instance",
    "raw-comment": "/**\n * Increase the reference count of an toplist browse result\n *\n * @param[in]   tlb       The toplist browse result object\n * @return                One of the following errors, from ::sp_error\n *                        SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "tlb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_toplistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_toplistbrowse_release",
    "kind": "instance",
    "raw-comment": "/**\n * Decrease the reference count of an toplist browse result\n *\n * @param[in]   tlb       The toplist browse result object\n * @return                One of the following errors, from ::sp_error\n *                        SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "tlb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_toplistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_toplistbrowse_num_artists",
    "kind": "instance",
    "raw-comment": "/**\n * Given an toplist browse object, return number of artists\n *\n * @param[in]   tlb         Toplist browse object\n *\n * @return                  Number of artists on toplist\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "tlb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_toplistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_toplistbrowse_artist",
    "kind": "instance",
    "raw-comment": "/**\n * Return the artist at the given index in the given toplist browse object\n *\n * @param[in]  tlb        Toplist object\n * @param[in]  index      Index of the wanted artist. Should be in the interval [0, sp_toplistbrowse_num_artists() - 1]\n *\n * @return                The artist at the given index in the given toplist browse object\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "tlb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_toplistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_artist",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_toplistbrowse_num_albums",
    "kind": "instance",
    "raw-comment": "/**\n * Given an toplist browse object, return number of albums\n *\n * @param[in]   tlb         Toplist browse object\n *\n * @return                  Number of albums on toplist\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "tlb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_toplistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_toplistbrowse_album",
    "kind": "instance",
    "raw-comment": "/**\n * Return the album at the given index in the given toplist browse object\n *\n * @param[in]  tlb        Toplist object\n * @param[in]  index      Index of the wanted album. Should be in the interval [0, sp_toplistbrowse_num_albums() - 1]\n *\n * @return                The album at the given index in the given toplist browse object\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "tlb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_toplistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_album",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_toplistbrowse_num_tracks",
    "kind": "instance",
    "raw-comment": "/**\n * Given an toplist browse object, return number of tracks\n *\n * @param[in]   tlb         Toplist browse object\n *\n * @return                  Number of tracks on toplist\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "tlb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_toplistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_toplistbrowse_track",
    "kind": "instance",
    "raw-comment": "/**\n * Return the track at the given index in the given toplist browse object\n *\n * @param[in]  tlb        Toplist object\n * @param[in]  index      Index of the wanted track. Should be in the interval [0, sp_toplistbrowse_num_tracks() - 1]\n *\n * @return                The track at the given index in the given toplist browse object\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "tlb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_toplistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "index",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_track",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_toplistbrowse_backend_request_duration",
    "kind": "instance",
    "raw-comment": "/**\n * Return the time (in ms) that was spent waiting for the Spotify backend to serve the request\n *\n * @param[in]  tlb        Toplist object\n *\n * @return                -1 if the request was served from the local cache\n *                        If the result is not yet loaded the return value is undefined\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "tlb",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_toplistbrowse",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "int",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "inboxpost_complete_cb",
    "kind": "typedef",
    "raw-comment": "/**\n * The type of a callback used in sp_inbox_post()\n *\n * When this callback is called, the sp_track_is_loaded(), sp_album_is_loaded(),\n * and sp_artist_is_loaded() functions will return non-zero for the objects\n * contained in the search result.\n *\n * @param[in]   result          The same pointer returned by sp_search_create()\n * @param[in]   userdata        The opaque pointer given to sp_search_create()\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "result",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_inbox",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "userdata",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "void",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "void",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_inbox_post_tracks",
    "kind": "instance",
    "raw-comment": "/**\n * Add to inbox\n *\n * @param[in]  session    Session object\n * @param[in]  user       Canonical username of recipient\n * @param[in]  tracks     Array of tracks to post\n * @param[in]  num_tracks Number of tracks in \\p tracks\n * @param[in]  message    Message to attach to tracks. UTF-8\n * @param[in]  callback   Callback to be invoked when the request has completed\n * @param[in]  userdata   Userdata passed to callback\n *\n * @return                sp_inbox object if the request has been sent, NULL if request failed to initialize\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "session",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_session",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "user",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "tracks",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "pointer",
              "to": {
                "kind": "named-type",
                "name": "sp_track",
                "qualifiers": []
              },
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "num_tracks",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "int",
            "qualifiers": []
          }
        },
        {
          "name": "message",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "char",
              "qualifiers": [
                "const"
              ]
            },
            "qualifiers": []
          }
        },
        {
          "name": "callback",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "inboxpost_complete_cb",
              "qualifiers": []
            },
            "qualifiers": []
          }
        },
        {
          "name": "userdata",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "void",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "sp_inbox",
          "qualifiers": []
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_inbox_error",
    "kind": "instance",
    "raw-comment": "/**\n* Check if inbox operation returned an error code.\n*\n* @param[in]   inbox      Inbox object\n*\n* @return                 One of the following errors, from ::sp_error\n*                         SP_ERROR_OK\n*                         SP_ERROR_OTHER_TRANSIENT\n*                         SP_ERROR_PERMISSION_DENIED\n*                         SP_ERROR_INVALID_INDATA\n*                         SP_ERROR_INBOX_IS_FULL\n*                         SP_ERROR_NO_SUCH_USER\n*                         SP_ERROR_OTHER_PERMANENT\n*/",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "inbox",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_inbox",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_inbox_add_ref",
    "kind": "instance",
    "raw-comment": "/**\n * Increase the reference count of a inbox result\n *\n * @param[in]   inbox    The inbox result object\n * @return               One of the following errors, from ::sp_error\n *                       SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "inbox",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_inbox",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_inbox_release",
    "kind": "instance",
    "raw-comment": "/**\n * Decrease the reference count of a inbox result\n *\n * @param[in]   inbox    The inbox result object\n * @return               One of the following errors, from ::sp_error\n *                       SP_ERROR_OK\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "inbox",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "pointer",
            "to": {
              "kind": "named-type",
              "name": "sp_inbox",
              "qualifiers": []
            },
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "named-type",
        "name": "sp_error",
        "qualifiers": []
      },
      "qualifiers": []
    }
  },
  {
    "name": "sp_build_id",
    "kind": "instance",
    "raw-comment": "/**\n * Return the libspotify build ID\n *\n * This might be useful to have available for display somewhere in your\n * user interface.\n */",
    "type": {
      "kind": "function",
      "arguments": [
        {
          "name": "",
          "kind": "instance",
          "raw-comment": null,
          "type": {
            "kind": "named-type",
            "name": "void",
            "qualifiers": []
          }
        }
      ],
      "returning": {
        "kind": "pointer",
        "to": {
          "kind": "named-type",
          "name": "char",
          "qualifiers": [
            "const"
          ]
        },
        "qualifiers": []
      },
      "qualifiers": []
    }
  }
]